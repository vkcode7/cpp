<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol.lst-kix_jqtponp32vkl-3.start{counter-reset:lst-ctn-kix_jqtponp32vkl-3 0}.lst-kix_1c8d1l2jxfms-8>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-8,lower-roman) ". "}ul.lst-kix_at6436p7wv79-7{list-style-type:none}ul.lst-kix_at6436p7wv79-8{list-style-type:none}.lst-kix_1c8d1l2jxfms-6>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-6,decimal) ". "}.lst-kix_1c8d1l2jxfms-7>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-7,lower-latin) ". "}ul.lst-kix_at6436p7wv79-5{list-style-type:none}ul.lst-kix_at6436p7wv79-6{list-style-type:none}.lst-kix_1c8d1l2jxfms-2>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-2}ol.lst-kix_jqtponp32vkl-8{list-style-type:none}.lst-kix_1c8d1l2jxfms-2>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-2,lower-roman) ". "}.lst-kix_1c8d1l2jxfms-3>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-3,decimal) ". "}ol.lst-kix_jqtponp32vkl-7{list-style-type:none}ol.lst-kix_jqtponp32vkl-6{list-style-type:none}ol.lst-kix_jqtponp32vkl-5{list-style-type:none}.lst-kix_1c8d1l2jxfms-0>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-0,decimal) ". "}.lst-kix_1c8d1l2jxfms-1>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-1,lower-latin) ". "}.lst-kix_1c8d1l2jxfms-4>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-4,lower-latin) ". "}.lst-kix_1c8d1l2jxfms-5>li:before{content:"" counter(lst-ctn-kix_1c8d1l2jxfms-5,lower-roman) ". "}ol.lst-kix_jqtponp32vkl-0{list-style-type:none}ol.lst-kix_jqtponp32vkl-4{list-style-type:none}ol.lst-kix_jqtponp32vkl-3{list-style-type:none}ol.lst-kix_jqtponp32vkl-2{list-style-type:none}ol.lst-kix_jqtponp32vkl-1{list-style-type:none}.lst-kix_1c8d1l2jxfms-0>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-0}ol.lst-kix_1c8d1l2jxfms-0.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-0 0}.lst-kix_y2vjafk28ump-6>li:before{content:"\0025cf   "}.lst-kix_y2vjafk28ump-5>li:before{content:"\0025a0   "}.lst-kix_y2vjafk28ump-4>li:before{content:"\0025cb   "}.lst-kix_y2vjafk28ump-7>li:before{content:"\0025cb   "}ol.lst-kix_jqtponp32vkl-4.start{counter-reset:lst-ctn-kix_jqtponp32vkl-4 0}.lst-kix_y2vjafk28ump-8>li:before{content:"\0025a0   "}.lst-kix_jqtponp32vkl-1>li{counter-increment:lst-ctn-kix_jqtponp32vkl-1}.lst-kix_y2vjafk28ump-2>li:before{content:"\0025a0   "}.lst-kix_at6436p7wv79-0>li:before{content:"\0025cf   "}.lst-kix_y2vjafk28ump-1>li:before{content:"\0025cb   "}.lst-kix_y2vjafk28ump-3>li:before{content:"\0025cf   "}.lst-kix_y2vjafk28ump-0>li:before{content:"\0025a0   "}.lst-kix_usr5mcx46zsr-4>li:before{content:"-  "}.lst-kix_at6436p7wv79-7>li:before{content:"\0025cb   "}.lst-kix_kbvgo4mpevf-6>li:before{content:"\0025cf   "}.lst-kix_jqtponp32vkl-6>li{counter-increment:lst-ctn-kix_jqtponp32vkl-6}.lst-kix_at6436p7wv79-3>li:before{content:"\0025cf   "}.lst-kix_usr5mcx46zsr-2>li:before{content:"-  "}.lst-kix_at6436p7wv79-1>li:before{content:"\0025cb   "}.lst-kix_kbvgo4mpevf-0>li:before{content:"\0025cf   "}.lst-kix_kbvgo4mpevf-8>li:before{content:"\0025a0   "}.lst-kix_jqtponp32vkl-5>li{counter-increment:lst-ctn-kix_jqtponp32vkl-5}.lst-kix_usr5mcx46zsr-8>li:before{content:"-  "}.lst-kix_kbvgo4mpevf-2>li:before{content:"\0025a0   "}.lst-kix_usr5mcx46zsr-6>li:before{content:"-  "}.lst-kix_at6436p7wv79-5>li:before{content:"\0025a0   "}.lst-kix_kbvgo4mpevf-4>li:before{content:"\0025cb   "}ol.lst-kix_1c8d1l2jxfms-1.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-1 0}.lst-kix_1c8d1l2jxfms-5>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-5}ol.lst-kix_1c8d1l2jxfms-0{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-1{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-4{list-style-type:none}.lst-kix_6bxb5fjs3xf-8>li:before{content:"\0025a0   "}ol.lst-kix_1c8d1l2jxfms-5{list-style-type:none}.lst-kix_ulac14q164k7-3>li:before{content:"\0025cf   "}ol.lst-kix_1c8d1l2jxfms-2{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-3{list-style-type:none}.lst-kix_ulftpjk6bga3-6>li:before{content:"\0025cf   "}.lst-kix_ulftpjk6bga3-8>li:before{content:"\0025a0   "}ol.lst-kix_1c8d1l2jxfms-8{list-style-type:none}.lst-kix_ulac14q164k7-1>li:before{content:"\0025cb   "}.lst-kix_ulac14q164k7-5>li:before{content:"\0025a0   "}ol.lst-kix_1c8d1l2jxfms-6{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-7{list-style-type:none}.lst-kix_psspc8e7mlhb-1>li:before{content:"\0025cb   "}.lst-kix_6bxb5fjs3xf-4>li:before{content:"\0025cb   "}.lst-kix_6bxb5fjs3xf-2>li:before{content:"\0025a0   "}.lst-kix_psspc8e7mlhb-3>li:before{content:"\0025cf   "}.lst-kix_6bxb5fjs3xf-0>li:before{content:"\0025cf   "}.lst-kix_ulftpjk6bga3-0>li:before{content:"\0025cf   "}ol.lst-kix_jqtponp32vkl-1.start{counter-reset:lst-ctn-kix_jqtponp32vkl-1 0}.lst-kix_ulftpjk6bga3-2>li:before{content:"\0025a0   "}.lst-kix_ulftpjk6bga3-4>li:before{content:"\0025cb   "}ol.lst-kix_jqtponp32vkl-2.start{counter-reset:lst-ctn-kix_jqtponp32vkl-2 0}ul.lst-kix_at6436p7wv79-0{list-style-type:none}ul.lst-kix_usr5mcx46zsr-7{list-style-type:none}ul.lst-kix_usr5mcx46zsr-8{list-style-type:none}ul.lst-kix_usr5mcx46zsr-5{list-style-type:none}ul.lst-kix_at6436p7wv79-3{list-style-type:none}ul.lst-kix_usr5mcx46zsr-6{list-style-type:none}ul.lst-kix_at6436p7wv79-4{list-style-type:none}ul.lst-kix_usr5mcx46zsr-3{list-style-type:none}ul.lst-kix_at6436p7wv79-1{list-style-type:none}.lst-kix_psspc8e7mlhb-5>li:before{content:"\0025a0   "}ul.lst-kix_usr5mcx46zsr-4{list-style-type:none}ul.lst-kix_at6436p7wv79-2{list-style-type:none}.lst-kix_1c8d1l2jxfms-4>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-4}.lst-kix_usr5mcx46zsr-0>li:before{content:"-  "}ul.lst-kix_usr5mcx46zsr-1{list-style-type:none}ul.lst-kix_usr5mcx46zsr-2{list-style-type:none}.lst-kix_ulac14q164k7-7>li:before{content:"\0025cb   "}ul.lst-kix_usr5mcx46zsr-0{list-style-type:none}.lst-kix_6bxb5fjs3xf-6>li:before{content:"\0025cf   "}.lst-kix_psspc8e7mlhb-7>li:before{content:"\0025cb   "}ul.lst-kix_ulac14q164k7-0{list-style-type:none}.lst-kix_jqtponp32vkl-0>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-0,decimal) ". "}ul.lst-kix_ulac14q164k7-1{list-style-type:none}ul.lst-kix_ulac14q164k7-2{list-style-type:none}.lst-kix_jqtponp32vkl-1>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-1,lower-latin) ". "}ul.lst-kix_ulac14q164k7-7{list-style-type:none}ul.lst-kix_9j89h9h47smr-7{list-style-type:none}ul.lst-kix_ulac14q164k7-8{list-style-type:none}ul.lst-kix_9j89h9h47smr-8{list-style-type:none}ul.lst-kix_9j89h9h47smr-5{list-style-type:none}.lst-kix_g3nddkh6g95a-6>li:before{content:"\0025cf   "}.lst-kix_g3nddkh6g95a-8>li:before{content:"\0025a0   "}ul.lst-kix_9j89h9h47smr-6{list-style-type:none}ul.lst-kix_ulac14q164k7-3{list-style-type:none}ul.lst-kix_9j89h9h47smr-3{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-8.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-8 0}ul.lst-kix_ulac14q164k7-4{list-style-type:none}ul.lst-kix_9j89h9h47smr-4{list-style-type:none}.lst-kix_jqtponp32vkl-6>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-6,decimal) ". "}ul.lst-kix_ulac14q164k7-5{list-style-type:none}ul.lst-kix_9j89h9h47smr-1{list-style-type:none}ul.lst-kix_ulac14q164k7-6{list-style-type:none}.lst-kix_g3nddkh6g95a-7>li:before{content:"\0025cb   "}ul.lst-kix_9j89h9h47smr-2{list-style-type:none}.lst-kix_3rakteqamdxr-0>li:before{content:"-  "}ul.lst-kix_9j89h9h47smr-0{list-style-type:none}.lst-kix_jqtponp32vkl-7>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-7,lower-latin) ". "}.lst-kix_jqtponp32vkl-8>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-8,lower-roman) ". "}.lst-kix_3rakteqamdxr-1>li:before{content:"-  "}ol.lst-kix_jqtponp32vkl-6.start{counter-reset:lst-ctn-kix_jqtponp32vkl-6 0}.lst-kix_9j89h9h47smr-0>li:before{content:"\0025cf   "}.lst-kix_9j89h9h47smr-1>li:before{content:"\0025cb   "}.lst-kix_9j89h9h47smr-2>li:before{content:"\0025a0   "}.lst-kix_3rakteqamdxr-8>li:before{content:"-  "}.lst-kix_3rakteqamdxr-7>li:before{content:"-  "}.lst-kix_1c8d1l2jxfms-3>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-3}.lst-kix_3rakteqamdxr-4>li:before{content:"-  "}ul.lst-kix_3rakteqamdxr-0{list-style-type:none}.lst-kix_3rakteqamdxr-3>li:before{content:"-  "}ul.lst-kix_3rakteqamdxr-1{list-style-type:none}.lst-kix_g3nddkh6g95a-0>li:before{content:"\0025cf   "}.lst-kix_3rakteqamdxr-2>li:before{content:"-  "}ul.lst-kix_3rakteqamdxr-2{list-style-type:none}ul.lst-kix_3rakteqamdxr-3{list-style-type:none}ul.lst-kix_3rakteqamdxr-4{list-style-type:none}ul.lst-kix_3rakteqamdxr-5{list-style-type:none}ul.lst-kix_psspc8e7mlhb-0{list-style-type:none}.lst-kix_g3nddkh6g95a-2>li:before{content:"\0025a0   "}.lst-kix_g3nddkh6g95a-4>li:before{content:"\0025cb   "}.lst-kix_g3nddkh6g95a-1>li:before{content:"\0025cb   "}.lst-kix_g3nddkh6g95a-5>li:before{content:"\0025a0   "}.lst-kix_3rakteqamdxr-5>li:before{content:"-  "}.lst-kix_3rakteqamdxr-6>li:before{content:"-  "}.lst-kix_jqtponp32vkl-0>li{counter-increment:lst-ctn-kix_jqtponp32vkl-0}.lst-kix_g3nddkh6g95a-3>li:before{content:"\0025cf   "}ol.lst-kix_jqtponp32vkl-0.start{counter-reset:lst-ctn-kix_jqtponp32vkl-0 0}ul.lst-kix_y2vjafk28ump-8{list-style-type:none}ul.lst-kix_psspc8e7mlhb-8{list-style-type:none}ul.lst-kix_psspc8e7mlhb-7{list-style-type:none}ul.lst-kix_psspc8e7mlhb-6{list-style-type:none}ul.lst-kix_6bxb5fjs3xf-8{list-style-type:none}ul.lst-kix_psspc8e7mlhb-5{list-style-type:none}ul.lst-kix_psspc8e7mlhb-4{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-3.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-3 0}ul.lst-kix_psspc8e7mlhb-3{list-style-type:none}ul.lst-kix_psspc8e7mlhb-2{list-style-type:none}ul.lst-kix_psspc8e7mlhb-1{list-style-type:none}ul.lst-kix_3rakteqamdxr-6{list-style-type:none}ul.lst-kix_3rakteqamdxr-7{list-style-type:none}ul.lst-kix_3rakteqamdxr-8{list-style-type:none}ul.lst-kix_mx7nn8d0wjb9-3{list-style-type:none}ul.lst-kix_mx7nn8d0wjb9-4{list-style-type:none}ul.lst-kix_mx7nn8d0wjb9-5{list-style-type:none}.lst-kix_9j89h9h47smr-5>li:before{content:"\0025a0   "}ul.lst-kix_mx7nn8d0wjb9-6{list-style-type:none}.lst-kix_9j89h9h47smr-3>li:before{content:"\0025cf   "}ul.lst-kix_mx7nn8d0wjb9-0{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-2.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-2 0}ul.lst-kix_mx7nn8d0wjb9-1{list-style-type:none}ul.lst-kix_mx7nn8d0wjb9-2{list-style-type:none}.lst-kix_9j89h9h47smr-4>li:before{content:"\0025cb   "}.lst-kix_9j89h9h47smr-7>li:before{content:"\0025cb   "}.lst-kix_mx7nn8d0wjb9-7>li:before{content:"\0025cb   "}ul.lst-kix_mx7nn8d0wjb9-7{list-style-type:none}.lst-kix_9j89h9h47smr-6>li:before{content:"\0025cf   "}.lst-kix_jqtponp32vkl-7>li{counter-increment:lst-ctn-kix_jqtponp32vkl-7}ul.lst-kix_mx7nn8d0wjb9-8{list-style-type:none}.lst-kix_jqtponp32vkl-4>li{counter-increment:lst-ctn-kix_jqtponp32vkl-4}.lst-kix_mx7nn8d0wjb9-8>li:before{content:"\0025a0   "}ul.lst-kix_6bxb5fjs3xf-3{list-style-type:none}ul.lst-kix_6bxb5fjs3xf-2{list-style-type:none}ul.lst-kix_6bxb5fjs3xf-1{list-style-type:none}.lst-kix_mx7nn8d0wjb9-1>li:before{content:"\0025cb   "}.lst-kix_mx7nn8d0wjb9-3>li:before{content:"\0025cf   "}ul.lst-kix_6bxb5fjs3xf-0{list-style-type:none}ul.lst-kix_6bxb5fjs3xf-7{list-style-type:none}ul.lst-kix_6bxb5fjs3xf-6{list-style-type:none}.lst-kix_jqtponp32vkl-5>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-5,lower-roman) ". "}ul.lst-kix_6bxb5fjs3xf-5{list-style-type:none}.lst-kix_mx7nn8d0wjb9-2>li:before{content:"\0025a0   "}.lst-kix_mx7nn8d0wjb9-6>li:before{content:"\0025cf   "}ul.lst-kix_6bxb5fjs3xf-4{list-style-type:none}ul.lst-kix_y2vjafk28ump-0{list-style-type:none}.lst-kix_9j89h9h47smr-8>li:before{content:"\0025a0   "}ul.lst-kix_y2vjafk28ump-1{list-style-type:none}.lst-kix_jqtponp32vkl-3>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-3,decimal) ". "}.lst-kix_jqtponp32vkl-4>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-4,lower-latin) ". "}ul.lst-kix_y2vjafk28ump-2{list-style-type:none}ul.lst-kix_y2vjafk28ump-3{list-style-type:none}.lst-kix_mx7nn8d0wjb9-5>li:before{content:"\0025a0   "}ol.lst-kix_jqtponp32vkl-5.start{counter-reset:lst-ctn-kix_jqtponp32vkl-5 0}ul.lst-kix_y2vjafk28ump-4{list-style-type:none}ul.lst-kix_y2vjafk28ump-5{list-style-type:none}.lst-kix_jqtponp32vkl-2>li:before{content:"" counter(lst-ctn-kix_jqtponp32vkl-2,lower-roman) ". "}ul.lst-kix_y2vjafk28ump-6{list-style-type:none}ul.lst-kix_y2vjafk28ump-7{list-style-type:none}.lst-kix_mx7nn8d0wjb9-4>li:before{content:"\0025cb   "}.lst-kix_at6436p7wv79-6>li:before{content:"\0025cf   "}.lst-kix_at6436p7wv79-8>li:before{content:"\0025a0   "}.lst-kix_usr5mcx46zsr-1>li:before{content:"-  "}.lst-kix_usr5mcx46zsr-5>li:before{content:"-  "}.lst-kix_kbvgo4mpevf-5>li:before{content:"\0025a0   "}.lst-kix_at6436p7wv79-2>li:before{content:"\0025a0   "}.lst-kix_1c8d1l2jxfms-7>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-7}.lst-kix_usr5mcx46zsr-3>li:before{content:"-  "}.lst-kix_kbvgo4mpevf-7>li:before{content:"\0025cb   "}.lst-kix_mx7nn8d0wjb9-0>li:before{content:"\0025cf   "}.lst-kix_kbvgo4mpevf-1>li:before{content:"\0025cb   "}.lst-kix_at6436p7wv79-4>li:before{content:"\0025cb   "}.lst-kix_usr5mcx46zsr-7>li:before{content:"-  "}.lst-kix_kbvgo4mpevf-3>li:before{content:"\0025cf   "}.lst-kix_1c8d1l2jxfms-6>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-6}ul.lst-kix_ulftpjk6bga3-6{list-style-type:none}ul.lst-kix_ulftpjk6bga3-7{list-style-type:none}ul.lst-kix_ulftpjk6bga3-4{list-style-type:none}ul.lst-kix_ulftpjk6bga3-5{list-style-type:none}ul.lst-kix_ulftpjk6bga3-2{list-style-type:none}ul.lst-kix_ulftpjk6bga3-3{list-style-type:none}ul.lst-kix_ulftpjk6bga3-0{list-style-type:none}ul.lst-kix_ulftpjk6bga3-1{list-style-type:none}ol.lst-kix_1c8d1l2jxfms-7.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-7 0}ol.lst-kix_1c8d1l2jxfms-4.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-4 0}ol.lst-kix_jqtponp32vkl-7.start{counter-reset:lst-ctn-kix_jqtponp32vkl-7 0}ul.lst-kix_ulftpjk6bga3-8{list-style-type:none}.lst-kix_1c8d1l2jxfms-8>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-8}.lst-kix_jqtponp32vkl-3>li{counter-increment:lst-ctn-kix_jqtponp32vkl-3}ul.lst-kix_g3nddkh6g95a-2{list-style-type:none}.lst-kix_ulac14q164k7-4>li:before{content:"\0025cb   "}ul.lst-kix_g3nddkh6g95a-3{list-style-type:none}.lst-kix_6bxb5fjs3xf-7>li:before{content:"\0025cb   "}ul.lst-kix_g3nddkh6g95a-0{list-style-type:none}.lst-kix_psspc8e7mlhb-0>li:before{content:"\0025a0   "}ul.lst-kix_g3nddkh6g95a-1{list-style-type:none}ol.lst-kix_jqtponp32vkl-8.start{counter-reset:lst-ctn-kix_jqtponp32vkl-8 0}.lst-kix_ulftpjk6bga3-5>li:before{content:"\0025a0   "}.lst-kix_psspc8e7mlhb-2>li:before{content:"\0025a0   "}.lst-kix_6bxb5fjs3xf-3>li:before{content:"\0025cf   "}ul.lst-kix_g3nddkh6g95a-8{list-style-type:none}ul.lst-kix_g3nddkh6g95a-6{list-style-type:none}.lst-kix_ulac14q164k7-2>li:before{content:"\0025a0   "}ul.lst-kix_g3nddkh6g95a-7{list-style-type:none}ul.lst-kix_g3nddkh6g95a-4{list-style-type:none}.lst-kix_ulftpjk6bga3-7>li:before{content:"\0025cb   "}ul.lst-kix_g3nddkh6g95a-5{list-style-type:none}.lst-kix_jqtponp32vkl-2>li{counter-increment:lst-ctn-kix_jqtponp32vkl-2}.lst-kix_6bxb5fjs3xf-1>li:before{content:"\0025cb   "}ol.lst-kix_1c8d1l2jxfms-6.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-6 0}.lst-kix_ulftpjk6bga3-1>li:before{content:"\0025cb   "}.lst-kix_ulac14q164k7-0>li:before{content:"\0025a0   "}.lst-kix_jqtponp32vkl-8>li{counter-increment:lst-ctn-kix_jqtponp32vkl-8}.lst-kix_ulftpjk6bga3-3>li:before{content:"\0025cf   "}ul.lst-kix_kbvgo4mpevf-3{list-style-type:none}ul.lst-kix_kbvgo4mpevf-2{list-style-type:none}ul.lst-kix_kbvgo4mpevf-1{list-style-type:none}ul.lst-kix_kbvgo4mpevf-0{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_psspc8e7mlhb-6>li:before{content:"\0025cf   "}ol.lst-kix_1c8d1l2jxfms-5.start{counter-reset:lst-ctn-kix_1c8d1l2jxfms-5 0}.lst-kix_psspc8e7mlhb-4>li:before{content:"\0025cb   "}.lst-kix_psspc8e7mlhb-8>li:before{content:"\0025a0   "}ul.lst-kix_kbvgo4mpevf-7{list-style-type:none}ul.lst-kix_kbvgo4mpevf-6{list-style-type:none}.lst-kix_ulac14q164k7-8>li:before{content:"\0025a0   "}.lst-kix_1c8d1l2jxfms-1>li{counter-increment:lst-ctn-kix_1c8d1l2jxfms-1}ul.lst-kix_kbvgo4mpevf-5{list-style-type:none}.lst-kix_6bxb5fjs3xf-5>li:before{content:"\0025a0   "}ul.lst-kix_kbvgo4mpevf-4{list-style-type:none}.lst-kix_ulac14q164k7-6>li:before{content:"\0025cf   "}ul.lst-kix_kbvgo4mpevf-8{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c33{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.3;border-left-width:0pt;border-top-style:solid;background-color:#ffffff;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c99{border-right-style:solid;padding:3pt 2pt 3pt 2pt;border-bottom-color:#c0c0c0;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#c0c0c0;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:51.8pt;border-top-color:#c0c0c0;border-bottom-style:solid}.c117{border-right-style:solid;padding:3pt 2pt 3pt 2pt;border-bottom-color:#c0c0c0;border-top-width:1pt;border-right-width:0pt;border-left-color:#c0c0c0;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:162.8pt;border-top-color:#c0c0c0;border-bottom-style:solid}.c49{border-right-style:solid;border-top-width:0pt;border-right-width:0pt;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;padding-right:0pt}.c39{border-right-style:solid;border-top-width:0pt;border-right-width:0pt;border-top-style:solid;background-color:#ffffff;border-bottom-width:0pt;border-bottom-style:solid;padding-right:0pt}.c5{background-color:#ffffff;margin-left:71pt;padding-top:3pt;padding-left:0pt;padding-bottom:6pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c15{background-color:#f9f9f9;color:#333333;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:9.5pt;font-family:"Courier New";font-style:normal}.c2{background-color:#f2f2f2;color:#161616;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Courier New";font-style:normal}.c13{background-color:#ffffff;color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.5pt;font-family:"Arial";font-style:normal}.c24{background-color:#f2f2f2;color:#161616;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:21.5pt;font-family:"Courier New";font-style:normal}.c0{background-color:#f2f2f2;color:#161616;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Courier New";font-style:normal}.c43{background-color:#ffff00;color:#333333;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Courier New";font-style:normal}.c31{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c45{color:#161616;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:21.5pt;font-family:"Courier New";font-style:normal}.c89{margin-left:51pt;padding-top:0pt;padding-bottom:1pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c123{padding-top:14.3pt;padding-left:9.8pt;padding-bottom:2.6pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c48{background-color:#ffffff;padding-top:18pt;padding-bottom:4pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c10{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Microsoft Yahei";font-style:normal}.c37{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.5pt;font-family:"Arial";font-style:normal}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Courier New";font-style:normal}.c74{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c91{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c36{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Microsoft Yahei";font-style:normal}.c63{padding-top:14.3pt;padding-left:9.8pt;padding-bottom:2.6pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c21{background-color:#ffffff;padding-top:0pt;padding-bottom:0pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c92{margin-left:54pt;padding-top:6pt;padding-bottom:6pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c105{padding-top:0pt;padding-bottom:0pt;line-height:1.3;orphans:2;widows:2;text-align:left}.c59{padding-top:14pt;padding-bottom:4pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c126{padding-top:0pt;padding-bottom:0pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c86{padding-top:12pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c107{padding-top:0pt;padding-bottom:0pt;line-height:1.3571;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c55{padding-top:4pt;padding-bottom:5pt;line-height:1.2;orphans:2;widows:2;text-align:left}.c67{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c95{padding-top:0pt;padding-bottom:0pt;line-height:1.3;orphans:2;widows:2;text-align:center}.c51{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#0000ff;font-weight:700}.c20{background-color:#f2f2f2;font-size:10.5pt;font-family:"Courier New";color:#006881;font-weight:400}.c61{background-color:#f2f2f2;color:#161616;font-weight:700;font-size:13pt;font-family:"Courier New"}.c9{background-color:#f2f2f2;font-size:10.5pt;font-family:"Courier New";color:#161616;font-weight:400}.c7{background-color:#ffffff;font-size:10pt;font-family:"Courier New";color:#161616;font-weight:400}.c40{font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c11{background-color:#f2f2f2;font-size:10.5pt;font-family:"Courier New";color:#0101fd;font-weight:400}.c3{background-color:#f2f2f2;font-size:10.5pt;font-family:"Courier New";color:#008000;font-weight:400}.c16{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#000080;font-weight:700}.c41{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#008000;font-weight:700}.c29{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#333333;font-weight:700}.c65{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#000040;font-weight:700}.c70{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#008080;font-weight:700}.c53{background-color:#f9f9f9;font-size:9.5pt;font-family:"Courier New";color:#003080;font-weight:700}.c62{background-color:#ffff00;color:#333333;font-weight:400;font-size:17pt;font-family:"Microsoft Yahei"}.c32{background-color:#ffffff;font-size:9.5pt;font-family:"Courier New";color:#188038;font-weight:400}.c25{background-color:#ffff00;font-size:10.5pt;font-family:"Courier New";color:#161616;font-weight:400}.c76{color:#333333;font-weight:400;font-size:17pt;font-family:"Microsoft Yahei"}.c69{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c22{font-size:12pt;font-family:"Microsoft Yahei";color:#333333;font-weight:400}.c88{border-spacing:0;border-collapse:collapse;margin-right:auto}.c109{-webkit-text-decoration-skip:none;color:#0645ad;text-decoration:underline;text-decoration-skip-ink:none}.c75{color:#333333;font-weight:700;font-size:12.5pt;font-family:"Arial"}.c104{color:#0645ad;font-weight:400;font-family:"Georgia";font-style:italic}.c44{background-color:#f2f2f2;font-family:"Courier New";color:#006881;font-weight:400}.c18{font-size:9.5pt;font-family:"Courier New";color:#0645ad;font-weight:400}.c30{font-size:12pt;font-family:"Courier New";color:#333333;font-weight:400}.c14{background-color:#f2f2f2;font-family:"Courier New";color:#161616;font-weight:400}.c17{background-color:#ffffff;font-family:"Courier New";color:#0101fd;font-weight:400}.c28{background-color:#f2f2f2;font-family:"Courier New";color:#0101fd;font-weight:400}.c38{background-color:#f2f2f2;font-family:"Courier New";color:#a31515;font-weight:400}.c6{background-color:#f2f2f2;font-family:"Courier New";color:#008000;font-weight:400}.c26{background-color:#f2f2f2;font-size:12pt;color:#161616}.c87{background-color:#ffff00;font-family:"Courier New";font-weight:700}.c8{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c73{font-family:"Times New Roman";font-style:italic;font-weight:400}.c34{font-size:12pt;font-style:italic;color:#161616}.c85{background-color:#ffff00;font-weight:700;font-family:"Arial"}.c57{text-decoration:none;vertical-align:baseline;font-style:normal}.c27{background-color:#ffffff;font-size:12pt;color:#161616}.c56{background-color:#f2f2f2;font-size:10pt;color:#188038}.c114{color:#008000;font-family:"Arial"}.c93{background-color:#f2f2f2;color:#1155cc}.c46{background-color:#ffffff;font-size:9.5pt}.c83{font-size:9.5pt;color:#188038}.c120{font-size:14pt;font-family:"Arial"}.c42{padding:0;margin:0}.c54{font-family:"Courier New";font-weight:400}.c102{font-family:"Courier New";color:#0000dd}.c66{font-size:10pt;color:#161616}.c50{color:#333333;font-size:9.5pt}.c72{font-size:11pt;color:#000000}.c60{color:#008000;font-size:7.5pt}.c110{background-color:#f2f2f2;font-family:"Courier New"}.c68{background-color:#ffff00;color:#0101fd}.c79{color:#161616;font-size:12pt}.c12{color:inherit;text-decoration:inherit}.c115{font-family:"Courier New";color:#339900}.c64{color:#161616;font-size:11pt}.c84{font-family:"Microsoft Yahei";font-weight:400}.c96{font-size:9.5pt}.c119{font-size:17pt}.c4{height:11pt}.c58{font-size:10.5pt}.c71{height:14pt}.c111{text-indent:36pt}.c19{margin-left:36pt}.c97{font-size:12pt}.c125{color:#0000ee}.c82{margin-left:65pt}.c78{font-size:10pt}.c127{height:19.5pt}.c100{background-color:#f9f9f9}.c80{color:#161616}.c118{color:#188038}.c77{color:#3366bb}.c112{font-size:13pt}.c108{color:#0101fd}.c116{color:#008000}.c94{color:#1155cc}.c101{background-color:#ffff00}.c81{color:#333333}.c121{font-size:12.5pt}.c47{padding-left:0pt}.c113{font-size:11pt}.c106{font-size:16pt}.c122{height:16pt}.c90{font-weight:700}.c124{margin-left:180pt}.c103{color:#000000}.c52{background-color:#ffffff}.c98{page-break-after:avoid}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c8 doc-content"><h2 class="c91" id="h.k69hrnz46mjm"><span class="c40 c106 c103">Containers library</span></h2><h2 class="c55 c52" id="h.rdjsg4zbt004"><span class="c50">The Containers library is a generic collection of class templates and algorithms that allow programmers to easily implement common data structures like queues, lists and stacks. There are two</span><span class="c60">(until C++11)</span><span class="c50">three</span><span class="c60">(since C++11)</span><span class="c37">&nbsp;classes of containers:</span></h2><ul class="c42 lst-kix_ulac14q164k7-0 start"><li class="c92 c47 c52 li-bullet-0"><h2 id="h.rdjsg4zbt004-1" style="display:inline"><span class="c37">sequence containers,</span></h2></li><li class="c92 c47 c52 li-bullet-0"><h2 id="h.rdjsg4zbt004-2" style="display:inline"><span class="c37">associative containers, and</span></h2></li></ul><a id="t.c02bbf40b9858217a99549a23e711972587dc529"></a><a id="t.0"></a><table class="c88"><tr class="c127"><td class="c52 c117" colspan="1" rowspan="1"><ul class="c42 lst-kix_y2vjafk28ump-0 start"><li class="c47 c52 c89 li-bullet-0"><h2 id="h.rdjsg4zbt004-3" style="display:inline"><span class="c37">unordered associative containers,</span></h2></li></ul></td><td class="c52 c99" colspan="1" rowspan="1"><h2 class="c48" id="h.rdjsg4zbt004-4"><span class="c60">(since C++11)</span></h2></td></tr></table><h2 class="c55 c52" id="h.rzq53tk2ghso"><span class="c40 c96 c103">each of which is designed to support a different set of operations.</span></h2><h3 class="c49 c63 c52" id="h.gu3kx77uq1s9"><span class="c75 c57">Sequence containers</span></h3><h2 class="c55 c52" id="h.bc1vjxjhzrce"><span class="c37">Sequence containers implement data structures which can be accessed sequentially. - </span></h2><ul class="c42 lst-kix_3rakteqamdxr-0 start"><li class="c55 c19 c47 c52 li-bullet-0"><h2 id="h.oh54d16jvjf3" style="display:inline"><span class="c37">array (static contiguous memory), </span></h2></li><li class="c55 c19 c47 c52 li-bullet-0"><h2 id="h.t1zlizjsnoe4" style="display:inline"><span class="c37">vector (dynamic contiguous memory), </span></h2></li><li class="c55 c19 c47 c52 li-bullet-0"><h2 id="h.jmfsj7apappb" style="display:inline"><span class="c37">forward_list (singly linked list), </span></h2></li><li class="c55 c19 c47 c52 li-bullet-0"><h2 id="h.hxi378o1zqjk" style="display:inline"><span class="c37">list (doubly linked list), </span></h2></li><li class="c55 c19 c47 c52 li-bullet-0"><h2 id="h.hbd5etd0fx5w" style="display:inline"><span class="c37">deque (double ended queue)</span></h2></li></ul><h3 class="c49 c63 c52" id="h.jpz3zhc6yvha"><span class="c57 c75">Associative containers</span></h3><h2 class="c55 c52" id="h.dsjgkrknagsm"><span class="c50">Associative containers implement sorted data structures that can be quickly searched (</span><span class="c73 c50">O(log n)</span><span class="c50">&nbsp;complexity).</span></h2><ul class="c42 lst-kix_usr5mcx46zsr-0 start"><li class="c1 c19 c47 li-bullet-0"><span>set - </span><span class="c46">collection of unique keys, </span><span class="c46 c90">sorted</span><span class="c46">&nbsp;by keys</span></li><li class="c1 c19 c47 li-bullet-0"><span class="c23">multiset -same as set but multiple keys of same value are allowed</span></li><li class="c1 c19 c47 li-bullet-0"><span>map - </span><span class="c46">collection of key-value pairs, sorted by keys, keys are unique</span></li><li class="c1 c19 c47 li-bullet-0"><span>multimap - same as map but multiple keys of same value are allowed</span></li></ul><h3 class="c49 c52 c63" id="h.3ud6yphovj5h"><span class="c81 c121 c90">Unordered associative containers </span><span class="c57 c78 c90 c114">(since C++11)</span></h3><h3 class="c49 c63 c52" id="h.dn3yodpt40g"><span class="c46 c81">Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (</span><span class="c73 c46 c81">O(1)</span><span class="c46 c81">&nbsp;average, </span><span class="c73 c46 c81">O(n)</span><span class="c13">&nbsp;worst-case complexity).</span></h3><ul class="c42 lst-kix_usr5mcx46zsr-0"><li class="c1 c19 c47 li-bullet-0"><span>unordered_set - </span><span class="c46">collection of unique keys, </span><span class="c46 c90">hashed</span><span class="c46">&nbsp;by keys</span></li><li class="c1 c19 c47 li-bullet-0"><span class="c23">unordered_multiset -same as set but multiple keys of same value are allowed</span></li><li class="c1 c19 c47 li-bullet-0"><span>unordered_map - </span><span class="c46">collection of key-value pairs, </span><span class="c46 c90">hashed</span><span class="c46">&nbsp;by keys, keys are unique</span></li><li class="c1 c19 c47 li-bullet-0"><span>unordered_multimap - same as map but multiple keys of same value are allowed</span></li></ul><h3 class="c49 c63 c52" id="h.ueo78eaoroae"><span class="c75 c57">Container adaptors</span></h3><h2 class="c55 c52" id="h.wobxbp1qyc8b"><span class="c37">Container adaptors provide a different interface for sequential containers.</span></h2><p class="c1"><span class="c23">stack: adapts a container to provide stack (LIFO data structure)</span></p><p class="c1"><span class="c23">queue: adapts a container to provide queue (FIFO data structure)</span></p><p class="c1"><span class="c23">priority_queue: adapts a container to provide priority queue</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c23">flat_set: (C++23): adapts a container to provide a collection of unique keys, sorted by keys</span></p><p class="c1"><span class="c23">flat_map:(C++23):adapts two containers to provide a collection of key-value pairs, sorted by unique keys</span></p><p class="c1"><span class="c23">flat_multiset: (C++23): adapts a container to provide a collection of keys, sorted by keys</span></p><p class="c1"><span class="c23">flat_multimap: (C++23): adapts two containers to provide a collection of key-value pairs, sorted by keys</span></p><p class="c1 c4"><span class="c23"></span></p><h2 class="c48 c122" id="h.krqnobkcjdun"><span class="c76 c57"></span></h2><h2 class="c48" id="h.oycwq3pqyfe6"><span class="c76 c57">C++ Containers and operations</span></h2><p class="c1"><span class="c69"><a class="c12" href="https://www.google.com/url?q=https://www.sandordargo.com/blog/2023/11/15/most-important-complexities&amp;sa=D&amp;source=editors&amp;ust=1712175538990431&amp;usg=AOvVaw2aUIxna2nCk1vPAQAAs8Iz">https://www.sandordargo.com/blog/2023/11/15/most-important-complexities</a></span></p><p class="c1 c4"><span class="c23"></span></p><p class="c67 c52"><span class="c36">First, let&rsquo;s see what are the most important containers you&rsquo;ll likely deal with in a coding interview, what are the underlying data structures and what are the related complexities. My goal is not to give you a deep analysis, just to provide you with the most necessary information, then you can do your own research.</span></p><h3 class="c59 c52" id="h.c7d38pbsjjky"><span class="c43">std::array</span></h3><p class="c67 c52"><span class="c54 c81">std::array</span><span class="c36">&nbsp;is a fixed-size array, storing objects in contiguous memory locations.</span></p><ul class="c42 lst-kix_at6436p7wv79-0 start"><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing the first element: with </span><span class="c30">front()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing the last element: with </span><span class="c30">back()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing a random element: with </span><span class="c30">at()</span><span class="c22">&nbsp;or with </span><span class="c30">operator[]</span><span class="c22">&nbsp;both have a complexity of </span><span class="c30 c57">O(1)</span></li></ul><p class="c1"><span class="c35">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c35">#include &lt;array&gt;</span></p><p class="c1"><span class="c35">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c35">#include &lt;iterator&gt;</span></p><p class="c1"><span class="c35">#include &lt;string&gt;</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">int main()</span></p><p class="c1"><span class="c35">{</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Construction uses aggregate initialization</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::array&lt;int, 3&gt; a1{{5, 4, 3}}; </span></p><p class="c1 c19 c111"><span class="c35">// Double-braces required prior to C++11 &nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::array&lt;int, 3&gt; a2 = {1, 2, 3}; // Double braces never required</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Container operations are supported</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::sort(a1.begin(), a1.end());</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; for (const auto&amp; k : a1)</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; k &lt;&lt; &#39; &#39;;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::cout &lt;&lt; &#39;\n&#39;;</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Ranged for loop is supported</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::array&lt;std::string, 2&gt; a3{&quot;E&quot;, &quot;\u018E&quot;};</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; for (const auto&amp; s : a3)</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; s &lt;&lt; &#39; &#39;;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::cout &lt;&lt; &#39;\n&#39;;</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Deduction guide for array creation (since C++17)</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; [[maybe_unused]] std::array a4{3.0, 1.0, 4.0}; // std::array&lt;double, 3&gt;</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Behavior of unspecified elements is the same as with built-in arrays</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; [[maybe_unused]] std::array&lt;int, 2&gt; a5; // No list init, a5[0] and a5[1]</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // are default initialized</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; [[maybe_unused]] std::array&lt;int, 2&gt; a6{}; // List init, both elements are value</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // initialized, a6[0] = a6[1] = 0</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; [[maybe_unused]] std::array&lt;int, 2&gt; a7{1}; // List init, unspecified element is value</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// initialized, a7[0] = 1, a7[1] = 0</span></p><p class="c1"><span class="c54">}</span></p><p class="c67 c4 c52"><span class="c30 c57"></span></p><h3 class="c59 c52" id="h.p0nep16x2b49"><span class="c43">std::list</span></h3><p class="c67 c52"><span class="c54 c81">std::list</span><span class="c84 c81">&nbsp;is a container that supports fast insertion and removal, but doesn&rsquo;t support fast random access. It is usually implemented as a doubly-linked list. </span><span class="c54 c81">std::forward_list</span><span class="c36">&nbsp;is similar, but implemented with a singly-linked list, so it&rsquo;s more space efficient, but it supports iteration only in one direction</span></p><ul class="c42 lst-kix_kbvgo4mpevf-0 start"><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing the first element: with </span><span class="c30">front()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing the last element: with </span><span class="c30">back()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;(not supported by </span><span class="c30">std::forward_list</span><span class="c10">)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c10">accessing a random element: not supported</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting at the front: with </span><span class="c30">push_front()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting at the back: with </span><span class="c30">push_back()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;(not supported by </span><span class="c30">std::forward_list</span><span class="c10">)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting at a random location: with </span><span class="c30">insert()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;for one element, and complexity of </span><span class="c30">O(n)</span><span class="c22">&nbsp;for multiple elements, where </span><span class="c30">n</span><span class="c22">&nbsp;is the number of elements to be inserted (</span><span class="c30">insert_after</span><span class="c22">&nbsp;for </span><span class="c30">std::forward_list</span><span class="c10">)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item from the front: with </span><span class="c30">pop_front()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item from the back: with </span><span class="c30">pop_back()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;(not supported by </span><span class="c30">std::forward_list</span><span class="c10">)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item from a random location: with </span><span class="c30">erase()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;for one element, and a complexity of </span><span class="c30">O(n)</span><span class="c22">&nbsp;for multiple elements, where </span><span class="c30">n</span><span class="c22">&nbsp;is the number of elements to be erased (</span><span class="c30">erase_after</span><span class="c22">&nbsp;for </span><span class="c30">std::forward_list</span><span class="c10">)</span></li></ul><p class="c1"><span class="c35">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c35">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c35">#include &lt;list&gt;</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">int main()</span></p><p class="c1"><span class="c35">{</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Create a list containing integers</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::list&lt;int&gt; l = {7, 5, 16, 8};</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Add an integer to the front of the list</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; l.push_front(25);</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Add an integer to the back of the list</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; l.push_back(13);</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Insert an integer before 16 by searching</span></p><p class="c1"><span class="c54">&nbsp; &nbsp; auto it =</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/algorithm/find&amp;sa=D&amp;source=editors&amp;ust=1712175538997273&amp;usg=AOvVaw0ICrtYJ_y7g5rhd24Ujtgp">&nbsp;std::find</a></span><span class="c35">(l.begin(), l.end(), 16);</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; if (it != l.end())</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; l.insert(it, 42);</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Print out the list</span></p><p class="c1"><span class="c54">&nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175538997756&amp;usg=AOvVaw0v8LL75J0YeiHH36vX1xQP">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; &quot;l = { &quot;;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; for (int n : l)</span></p><p class="c1"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175538998056&amp;usg=AOvVaw3QMKJSBxEORl-8stalaAG4">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; n &lt;&lt; &quot;, &quot;;</span></p><p class="c1"><span class="c54">&nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175538998304&amp;usg=AOvVaw2aE5VnlRz-LuFGi-Jx9L_T">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; &quot;};\n&quot;;</span></p><p class="c1"><span class="c35">}</span></p><p class="c67 c4 c52"><span class="c10"></span></p><h3 class="c59 c52" id="h.d7rmyug6c4zp"><span class="c87 c81 c112">std::forward_list</span></h3><p class="c67 c52"><span class="c32">std::forward_list</span><span class="c46 c81">&nbsp;is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list. Compared to </span><span class="c18 c52"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/container/list&amp;sa=D&amp;source=editors&amp;ust=1712175538998883&amp;usg=AOvVaw0H4FF0fNk2qGQQm6Vwcxyp">std::list</a></span><span class="c13">&nbsp;this container provides more space efficient storage when bidirectional iteration is not needed.</span></p><p class="c67 c52"><span class="c13">Important functions: front, pop_front, push_front, swap, empty, clear, insert_after, emplace_front, emplace_after</span></p><h3 class="c59 c52" id="h.d8wh1zjs4nly"><span class="c43">std::vector</span></h3><p class="c67 c52"><span class="c54 c81">std::vector</span><span class="c84 c81">&nbsp;</span><span class="c84 c81 c101">is a dynamically sized sequence container, where the elements are stored contiguously. </span><span class="c36">Random access is cheap, as well as operations at the end, unless reallocation is required.</span></p><ul class="c42 lst-kix_mx7nn8d0wjb9-0 start"><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing the first element: with </span><span class="c30">front()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing the last element: with </span><span class="c30">back()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing a random element: with </span><span class="c30">at()</span><span class="c22">&nbsp;or with </span><span class="c30">operator[]</span><span class="c22">&nbsp;both have a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting at the front: with </span><span class="c30">insert()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(n+m)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c22">&nbsp;is the number of elements to insert and </span><span class="c30">m</span><span class="c10">&nbsp;is the size of the container</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting at the back: with </span><span class="c30">push_back()</span><span class="c22">&nbsp;which has a complexity of amortized </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting at a random location: with </span><span class="c30">insert()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(n+m)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c22">&nbsp;is the number of elements to insert and </span><span class="c30">m</span><span class="c10">&nbsp;is the distance between the elements to insert and the end of the container</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item from the front: with </span><span class="c30">erase()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(n+m)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c22">&nbsp;is the number of elements erased (calls to the destructor) and </span><span class="c30">m</span><span class="c10">&nbsp;is the number of assignments to make - the size of the elements left in the vector</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item from the back: with </span><span class="c30">pop_back()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30 c57">O(1)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item from a random location: with </span><span class="c30">erase()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(n+m)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c22">&nbsp;is the number of elements erased (calls to the destructor) and </span><span class="c30">m</span><span class="c10">&nbsp;is the number of assignments to make - at least the number of elements after the last erased item, worst the size of the whole container left</span></li></ul><p class="c21 c19"><span class="c35">#include &lt;iostream&gt;</span></p><p class="c21 c19"><span class="c35">#include &lt;vector&gt;</span></p><p class="c21 c19"><span class="c35">&nbsp;</span></p><p class="c21 c19"><span class="c35">int main()</span></p><p class="c21 c19"><span class="c35">{</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; // Create a vector containing integers</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; std::vector&lt;int&gt; v = {8, 4, 5, 9};</span></p><p class="c19 c21"><span class="c35">&nbsp;</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; // Add two more integers to vector</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; v.push_back(6);</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; v.push_back(9);</span></p><p class="c21 c19"><span class="c35">&nbsp;</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; // Overwrite element at position 2</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; v[2] = -1;</span></p><p class="c21 c19"><span class="c35">&nbsp;</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; // Print out the vector</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; for (int n : v)</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; n &lt;&lt; &#39; &#39;;</span></p><p class="c21 c19"><span class="c35">&nbsp; &nbsp; std::cout &lt;&lt; &#39;\n&#39;;</span></p><p class="c21 c19"><span class="c54">}</span></p><h3 class="c52 c59" id="h.uqx0bmvnfljn"><span class="c43">std::deque</span></h3><p class="c55 c52"><span class="c54 c118">std::deque</span><span class="c40 c81 c113">&nbsp;(double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.</span></p><p class="c55 c52"><span class="c81">As opposed to </span><span class="c54 c109"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/container/vector&amp;sa=D&amp;source=editors&amp;ust=1712175539001932&amp;usg=AOvVaw26mLW5KotF0IrTzTag3YPQ">std::vector</a></span><span class="c40 c81 c113">, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays, with additional bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared to vector&#39;s indexed access which performs only one.</span></p><p class="c55 c52"><span class="c81">The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a </span><span class="c109 c54"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/container/vector&amp;sa=D&amp;source=editors&amp;ust=1712175539002205&amp;usg=AOvVaw3S2qdmjO5KaOFku48z9K1o">std::vector</a></span><span class="c40 c81 c113">&nbsp;because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</span></p><p class="c55 c52"><span class="c23">The complexity (efficiency) of common operations on deques is as follows:</span></p><ul class="c42 lst-kix_psspc8e7mlhb-0 start"><li class="c47 c52 c92 li-bullet-0"><span>Random access - constant </span><span class="c73">O(1)</span><span class="c23">.</span></li><li class="c92 c47 c52 li-bullet-0"><span>Insertion or removal of elements at the end or beginning - constant </span><span class="c73">O(1)</span><span class="c23">.</span></li><li class="c92 c47 c52 li-bullet-0"><span>Insertion or removal of elements - linear </span><span class="c73">O(n)</span><span class="c23">.</span></li></ul><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c23">Important methods are front(), back(), pop_front() and pop_back().</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c35">#include &lt;deque&gt;</span></p><p class="c1"><span class="c35">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c54 c72">&nbsp;</span></p><p class="c1"><span class="c35">int main()</span></p><p class="c1"><span class="c35">{</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Create a deque containing integers</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; std::deque&lt;int&gt; d = {7, 5, 16, 8};</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Add an integer to the beginning and end of the deque</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; d.push_front(13);</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; d.push_back(25);</span></p><p class="c1"><span class="c35">&nbsp;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; // Iterate and print values of deque</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; for (int n : d)</span></p><p class="c1"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539003480&amp;usg=AOvVaw01u34YbNgwfStvbWbAfxrd">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; n &lt;&lt; &#39; &#39;;</span></p><p class="c1"><span class="c54">&nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539003747&amp;usg=AOvVaw0bTZNM94FrPa2YAaz04EHf">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; &#39;\n&#39;;</span></p><p class="c1"><span class="c35">}</span></p><h3 class="c59 c71 c52" id="h.v4hleejmc0gz"><span class="c43"></span></h3><h3 class="c59 c52 c71" id="h.ssw9joeo4al2"><span class="c43"></span></h3><h3 class="c49 c63 c52" id="h.jjgsppg9gv7o"><span class="c101 c81 c90 c121">Associative containers - set, map, multiset, multimap</span></h3><h3 class="c59 c52" id="h.k773u0lg2acn"><span class="c43">std::set</span></h3><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c32">std::set</span><span class="c46">&nbsp;is an associative container that contains a sorted set of unique objects of type </span><span class="c32">Key</span><span class="c46">. Sorting is done using the key comparison function </span><span class="c46 c104"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/named_req/Compare&amp;sa=D&amp;source=editors&amp;ust=1712175539004491&amp;usg=AOvVaw0UhGy_M9wpatILPnaeLlTZ">Compare</a></span><span class="c46">. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as </span><span class="c46 c77"><a class="c12" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Red%25E2%2580%2593black_tree&amp;sa=D&amp;source=editors&amp;ust=1712175539004688&amp;usg=AOvVaw07DkLeHt7Og1Giv2tueUL1">Red&ndash;black trees</a></span></p><p class="c1 c4"><span class="c40 c46 c103"></span></p><p class="c1"><span class="c46">Noted functions: empty, size, max_size, count, erase, find, insert, emplace, clear</span></p><p class="c1 c4"><span class="c43"></span></p><p class="c1"><span class="c115 c96 c100 c90">#include &lt;set&gt;</span></p><p class="c1"><span class="c96 c100 c90 c115">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c15">&nbsp;</span></p><p class="c1"><span class="c51">int</span><span class="c29">&nbsp;main</span><span class="c41">()</span></p><p class="c1"><span class="c41">{</span></p><p class="c1"><span class="c29">&nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/container/set&amp;sa=D&amp;source=editors&amp;ust=1712175539005421&amp;usg=AOvVaw0_BHFSO6BsvIa3Dcfmi1mD">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/container/set&amp;sa=D&amp;source=editors&amp;ust=1712175539005578&amp;usg=AOvVaw2rzFvECm5sXY9UY32Y13wB">std::set</a></span><span class="c16">&lt;</span><span class="c51">int</span><span class="c16">&gt;</span><span class="c29">&nbsp;c </span><span class="c16">=</span><span class="c29">&nbsp;</span><span class="c41">{</span><span class="c16">1</span><span class="c29">, </span><span class="c16">2</span><span class="c29">, </span><span class="c16">3</span><span class="c29">, </span><span class="c16">4</span><span class="c29">, </span><span class="c16">1</span><span class="c29">, </span><span class="c16">2</span><span class="c29">, </span><span class="c16">3</span><span class="c29">, </span><span class="c16">4</span><span class="c41">}</span><span class="c70">;</span></p><p class="c1"><span class="c15">&nbsp;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; </span><span class="c51">auto</span><span class="c29">&nbsp;print </span><span class="c16">=</span><span class="c29">&nbsp;</span><span class="c41">[</span><span class="c65">&amp;</span><span class="c29">c</span><span class="c41">]</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; </span><span class="c41">{</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539006606&amp;usg=AOvVaw056cA-hv8j5z91qwfIpn-m">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539006763&amp;usg=AOvVaw3Wtp6hw5n-7rmL19tYS7Ro">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&quot;c = { &quot;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c96 c100 c90 c102">for</span><span class="c29">&nbsp;</span><span class="c41">(</span><span class="c51">int</span><span class="c29">&nbsp;n </span><span class="c70">:</span><span class="c29">&nbsp;c</span><span class="c41">)</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539007257&amp;usg=AOvVaw0GBikKEOMdEoq-kA4qVsEi">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539007434&amp;usg=AOvVaw3olH21r3SBwdtdt9NX5tPK">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;n </span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&#39; &#39;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539007939&amp;usg=AOvVaw0Houvgx8NN_hFBn2RKUTFK">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539008151&amp;usg=AOvVaw2UgNctYR9VTcjAab7RNXsX">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&quot;}\n&quot;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; </span><span class="c41">}</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; print</span><span class="c41">()</span><span class="c70">;</span></p><p class="c1"><span class="c15">&nbsp;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539008817&amp;usg=AOvVaw3N6bn8PCF1RatiA3XYIwXY">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539009010&amp;usg=AOvVaw3qjszZv_Q4HZOPq7ILzggB">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&quot;Erase all odd numbers:\n&quot;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; </span><span class="c102 c96 c100 c90">for</span><span class="c29">&nbsp;</span><span class="c41">(</span><span class="c51">auto</span><span class="c29">&nbsp;it </span><span class="c16">=</span><span class="c29">&nbsp;c.begin</span><span class="c41">()</span><span class="c70">;</span><span class="c29">&nbsp;it </span><span class="c65">!</span><span class="c16">=</span><span class="c29">&nbsp;c.end</span><span class="c41">()</span><span class="c70">;</span><span class="c41">)</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; </span><span class="c41">{</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c102 c96 c100 c90">if</span><span class="c29">&nbsp;</span><span class="c41">(</span><span class="c65">*</span><span class="c29">it </span><span class="c65">%</span><span class="c29">&nbsp;</span><span class="c16">2</span><span class="c29">&nbsp;</span><span class="c65">!</span><span class="c16">=</span><span class="c29">&nbsp;</span><span class="c16">0</span><span class="c41">)</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it </span><span class="c16">=</span><span class="c29">&nbsp;c.erase</span><span class="c41">(</span><span class="c29">it</span><span class="c41">)</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c102 c96 c100 c90">else</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c65">++</span><span class="c29">it</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; </span><span class="c41">}</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; print</span><span class="c41">()</span><span class="c70">;</span></p><p class="c1"><span class="c15">&nbsp;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539011000&amp;usg=AOvVaw3t1lWu5xcBZ5y1TG1aJTks">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539011178&amp;usg=AOvVaw1NyYNKzEmcWL73o8e1yLPn">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&quot;Erase 1, erased count: &quot;</span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;c.erase</span><span class="c41">(</span><span class="c16">1</span><span class="c41">)</span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&#39;\n&#39;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539011684&amp;usg=AOvVaw2siKkGpkYJqOOsRaeoqcKS">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539011840&amp;usg=AOvVaw3Q1uAOLE2nIzXUApk5RVUP">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&quot;Erase 2, erased count: &quot;</span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;c.erase</span><span class="c41">(</span><span class="c16">2</span><span class="c41">)</span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&#39;\n&#39;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp;</span><span class="c29"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539012388&amp;usg=AOvVaw3Yazgq4JCJA90WNvsJMaF5">&nbsp;</a></span><span class="c53"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539012628&amp;usg=AOvVaw29h5ygJv6YB6Hz1-2LSNST">std::cout</a></span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&quot;Erase 2, erased count: &quot;</span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;c.erase</span><span class="c41">(</span><span class="c16">2</span><span class="c41">)</span><span class="c29">&nbsp;</span><span class="c16">&lt;&lt;</span><span class="c29">&nbsp;</span><span class="c41">&#39;\n&#39;</span><span class="c70">;</span></p><p class="c1"><span class="c29">&nbsp; &nbsp; print</span><span class="c41">()</span><span class="c70">;</span></p><p class="c126"><span class="c41 c57">}</span></p><p class="c1 c4"><span class="c43"></span></p><h3 class="c59 c52" id="h.uel8aodzv3ls"><span class="c43">std::map</span></h3><p class="c67 c52"><span class="c54 c81">std::map</span><span class="c81 c84">&nbsp;</span><span class="c84 c101 c81">is a sorted associative container</span><span class="c84 c81">&nbsp;providing search, removal and insertion at a logarithmic complexity. </span><span class="c84 c101 c81">They are usually implemented as red-black trees</span><span class="c36">.</span></p><ul class="c42 lst-kix_g3nddkh6g95a-0 start"><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing an element: with </span><span class="c30">at()</span><span class="c22">&nbsp;or with </span><span class="c30">operator[]</span><span class="c22">&nbsp;both have a complexity of </span><span class="c30">O(log n)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the container</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting an element at a random location: with </span><span class="c30">insert()</span><span class="c22">&nbsp;or with </span><span class="c30">operator[]</span><span class="c22">&nbsp;both have a complexity of </span><span class="c30">O(log n)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c22">&nbsp;is the size of the container. With </span><span class="c30">insert()</span><span class="c22">&nbsp;you can insert multiple elements, and then the complexity becomes </span><span class="c30">O(m * log n)</span><span class="c22">, where </span><span class="c30">m</span><span class="c22">&nbsp;is the number of elements to insert. </span><span class="c30">insert()</span><span class="c22">&nbsp;can also take a position as a hint where to insert. If the insertion happens there then the complexity is amortized </span><span class="c30">O(1)</span><span class="c22">&nbsp;otherwise </span><span class="c30 c57">O(log n)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item: with </span><span class="c30">erase()</span><span class="c22">&nbsp;which has a complexity of amortized </span><span class="c30">O(1)</span><span class="c22">&nbsp;if the erasure happens with an iterator, otherwise it&rsquo;s </span><span class="c30">O(log(n) + m)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c22">&nbsp;is the size of the container and </span><span class="c30">m</span><span class="c10">&nbsp;is the number of elements to remove</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">finding an element: with </span><span class="c30">find()</span><span class="c22">&nbsp;which has a complexity of </span><span class="c30">O(log n)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the container</span></li></ul><p class="c1 c19"><span class="c23">#include &lt;iostream&gt;</span></p><p class="c1 c19"><span class="c23">#include &lt;map&gt;</span></p><p class="c1 c19"><span class="c23">#include &lt;string&gt;</span></p><p class="c1 c19"><span class="c23">#include &lt;string_view&gt;</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span>void print_map(</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/string/basic_string_view&amp;sa=D&amp;source=editors&amp;ust=1712175539015184&amp;usg=AOvVaw33JPT5kRaAXphERZiL2er4">std::string_view</a></span><span>&nbsp;comment, const std::map&lt;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/string/basic_string&amp;sa=D&amp;source=editors&amp;ust=1712175539015435&amp;usg=AOvVaw1gE0lhwnJTpNSLUZbiuUXU">std::string</a></span><span class="c23">, int&gt;&amp; m)</span></p><p class="c1 c19"><span class="c23">{</span></p><p class="c1 c19"><span>&nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539015708&amp;usg=AOvVaw21c7awset6Jb3vIXBwW4Jz">&nbsp;std::cout</a></span><span class="c23">&nbsp;&lt;&lt; comment;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; // Iterate using C++17 facilities</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; for (const auto&amp; [key, value] : m)</span></p><p class="c1 c19"><span>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539016055&amp;usg=AOvVaw2UeDQG04V-j-3w6BbWBb-d">&nbsp;std::cout</a></span><span class="c23">&nbsp;&lt;&lt; &#39;[&#39; &lt;&lt; key &lt;&lt; &quot;] = &quot; &lt;&lt; value &lt;&lt; &quot;; &quot;;</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">// C++11 alternative:</span></p><p class="c1 c19"><span class="c23">// &nbsp;for (const auto&amp; n : m)</span></p><p class="c1 c19"><span class="c23">// &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; n.first &lt;&lt; &quot; = &quot; &lt;&lt; n.second &lt;&lt; &quot;; &quot;;</span></p><p class="c1 c19"><span class="c23">//</span></p><p class="c1 c19"><span class="c23">// C++98 alternative:</span></p><p class="c1 c19"><span class="c23">// &nbsp;for (std::map&lt;std::string, int&gt;::const_iterator it = m.begin(); it != m.end(); ++it)</span></p><p class="c1 c19"><span class="c23">// &nbsp; &nbsp; &nbsp;std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; = &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;; &quot;;</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span>&nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539016722&amp;usg=AOvVaw3DAn_t5hdX5O6yc5I0LLKR">&nbsp;std::cout</a></span><span class="c23">&nbsp;&lt;&lt; &#39;\n&#39;;</span></p><p class="c1 c19"><span class="c23">}</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">int main()</span></p><p class="c1 c19"><span class="c23">{</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; // Create a map of three (string, int) pairs</span></p><p class="c1 c19"><span>&nbsp; &nbsp; std::map&lt;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/string/basic_string&amp;sa=D&amp;source=editors&amp;ust=1712175539017199&amp;usg=AOvVaw1zE4XKbC3WgOnYrRUllBqt">std::string</a></span><span class="c23">, int&gt; m{{&quot;CPU&quot;, 10}, {&quot;GPU&quot;, 15}, {&quot;RAM&quot;, 20}};</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; print_map(&quot;1) Initial map: &quot;, m);</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; m[&quot;CPU&quot;] = 25; // update an existing value</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; m[&quot;SSD&quot;] = 30; // insert a new value</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; print_map(&quot;2) Updated map: &quot;, m);</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; // Using operator[] with non-existent key always performs an insert</span></p><p class="c1 c19"><span>&nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539017812&amp;usg=AOvVaw0GTlxl0s918am_ml7oglkM">&nbsp;std::cout</a></span><span class="c23">&nbsp;&lt;&lt; &quot;3) m[UPS] = &quot; &lt;&lt; m[&quot;UPS&quot;] &lt;&lt; &#39;\n&#39;;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; print_map(&quot;4) Updated map: &quot;, m);</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; m.erase(&quot;GPU&quot;);</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; print_map(&quot;5) After erase: &quot;, m);</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span>&nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/container/vector/erase2&amp;sa=D&amp;source=editors&amp;ust=1712175539018290&amp;usg=AOvVaw3SuQ-Q80aeFmLGzj5LWh4m">&nbsp;std::erase_if</a></span><span class="c23">(m, [](const auto&amp; pair){ return pair.second &gt; 25; });</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; print_map(&quot;6) After erase: &quot;, m);</span></p><p class="c1 c19"><span>&nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539018643&amp;usg=AOvVaw0QR5JOA3Pf6HsdCS6h0mKH">&nbsp;std::cout</a></span><span class="c23">&nbsp;&lt;&lt; &quot;7) m.size() = &quot; &lt;&lt; m.size() &lt;&lt; &#39;\n&#39;;</span></p><p class="c1 c19"><span class="c23">&nbsp;</span></p><p class="c1 c19"><span class="c23">&nbsp; &nbsp; m.clear();</span></p><p class="c1 c19"><span>&nbsp; &nbsp;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539018941&amp;usg=AOvVaw2dZWbhwT0BhCbXNs_quBJx">&nbsp;std::cout</a></span><span>&nbsp;&lt;&lt;</span><span class="c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/manip/boolalpha&amp;sa=D&amp;source=editors&amp;ust=1712175539019116&amp;usg=AOvVaw1yCvd5XFms_LTNVVrgqeok">&nbsp;std::boolalpha</a></span><span class="c23">&nbsp;&lt;&lt; &quot;8) Map is empty: &quot; &lt;&lt; m.empty() &lt;&lt; &#39;\n&#39;;</span></p><p class="c1 c19"><span class="c23">}</span></p><p class="c67 c4 c19 c52"><span class="c10"></span></p><h3 class="c59 c52" id="h.2pxu5d26h78w"><span class="c43">std::multiset</span></h3><p class="c1"><span class="c32">std::multiset</span><span class="c40 c46 c103">&nbsp;is an associative container that contains a sorted set of objects of type Key. Unlike set, multiple keys with equivalent values are allowed. </span></p><p class="c1 c4"><span class="c40 c46 c103"></span></p><p class="c67 c52"><span class="c54 c50 c100">&nbsp;</span><span class="c54">&nbsp;</span><span class="c54 c69"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/container/multiset&amp;sa=D&amp;source=editors&amp;ust=1712175539019745&amp;usg=AOvVaw3SGYQu3sV7_m0x38RMUC0Z">&nbsp;std::multiset</a></span><span class="c35">&lt;int&gt; c = {1, 2, 3, 4, 1, 2, 3, 4};</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; auto print = [&amp;c]</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539020082&amp;usg=AOvVaw1bjGK7xM6yRHEidsfGpYaW">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; &quot;c = { &quot;;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; &nbsp; &nbsp; for (int n : c)</span></p><p class="c1"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539020349&amp;usg=AOvVaw14Vai580WSVUEwwck5hjOw">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; n &lt;&lt; &#39; &#39;;</span></p><p class="c1"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c69 c54"><a class="c12" href="https://www.google.com/url?q=http://en.cppreference.com/w/cpp/io/cout&amp;sa=D&amp;source=editors&amp;ust=1712175539020592&amp;usg=AOvVaw3IUkol2XgNGTKqPw0My-ks">&nbsp;std::cout</a></span><span class="c35">&nbsp;&lt;&lt; &quot;}\n&quot;;</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; };</span></p><p class="c1"><span class="c35">&nbsp; &nbsp; print();</span></p><p class="c1 c4"><span class="c35"></span></p><p class="c67 c52"><span class="c46 c81">find - </span><span class="c46 c81">Finds an element with key equivalent to </span><span class="c50 c54">key</span><span class="c13">. If there are several elements with the requested key in the container, any of them may be returned.</span></p><h3 class="c59 c52" id="h.gei65lc8l8jm"><span class="c43">std::multimap</span></h3><p class="c1"><span class="c32">std::multimap</span><span class="c46">&nbsp;is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key. </span></p><h3 class="c49 c52 c123" id="h.xr8qqzkxfrmx"><span class="c101 c81 c121 c90">Unordered associative containers (c++11 onwards) - unordered_set, unordered_map, unordered_multiset, unordered_multimap</span></h3><p class="c1 c4"><span class="c23"></span></p><h3 class="c59 c52" id="h.frcwxp59kqo"><span class="c43">std::unordered_set</span></h3><h3 class="c52 c55" id="h.et08yjxh3grf"><span class="c83 c54">std::unordered_set</span><span class="c50">&nbsp;is an associative container that contains a set of unique objects of type </span><span class="c83 c54">Key</span><span class="c37">. Search, insertion, and removal have average constant-time complexity.</span></h3><h3 class="c55 c52" id="h.et08yjxh3grf-5"><span class="c37">Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.</span></h3><h3 class="c55 c52" id="h.ibj5wn5lhqnl"><span class="c37">Container elements may not be modified (even by non const iterators) since modification could change an element&#39;s hash and corrupt the container.</span></h3><h3 class="c55 c52" id="h.twa0784gdipb"><span class="c50">Apart from usual functions, it also has bucket and hash related functions such as bucket_count (number of buckets), bucket_size (items in a bucket with index n), bucket (bucket for a key), hash_function (function used to hash the key)</span></h3><h3 class="c59 c52" id="h.f3d0pjtzgala"><span class="c43">std::unordered_map</span></h3><p class="c67 c52"><span class="c54 c81">std::unordered_map</span><span class="c84 c81">&nbsp;is an unsorted associative container optimized for search, removal and insertion which come at a constant time complexity. </span><span class="c54 c101 c81">std::unordered_map</span><span class="c36 c101">&nbsp;is a hash map internally.</span></p><ul class="c42 lst-kix_ulftpjk6bga3-0 start"><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">accessing an element: with </span><span class="c30">at()</span><span class="c22">&nbsp;or with </span><span class="c30">operator[]</span><span class="c22">&nbsp;both have a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;on average and </span><span class="c30">O(n)</span><span class="c22">&nbsp;at worst where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the container</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">inserting an element at a random location: with </span><span class="c30">insert()</span><span class="c22">&nbsp;or with </span><span class="c30">operator[]</span><span class="c22">&nbsp;both have a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;on average and </span><span class="c30">O(n)</span><span class="c22">&nbsp;at worst, where </span><span class="c30">n</span><span class="c22">&nbsp;is the size of the map. If </span><span class="c30">m</span><span class="c22">&nbsp;elements are inserted then the average case is </span><span class="c30">O(m)</span><span class="c22">&nbsp;and the worst case is </span><span class="c30 c57">O(m * n + n)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">removing an item: with </span><span class="c30">erase()</span><span class="c22">&nbsp;which has a complexity of amortized </span><span class="c30">O(1)</span><span class="c22">&nbsp;if the erasure happens with an iterator, otherwise, on average it&rsquo;s </span><span class="c30">O(m)</span><span class="c22">&nbsp;where </span><span class="c30">m</span><span class="c22">&nbsp;is the number of elements to remove, worst case it&rsquo;s </span><span class="c30">O(n)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the container</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c22">finding an element: with </span><span class="c30">find()</span><span class="c22">&nbsp;it&rsquo;s </span><span class="c30">O(1)</span><span class="c22">&nbsp;on average and in the worst case it&rsquo;s </span><span class="c30">O(n)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the container</span></li></ul><h3 class="c59 c52" id="h.wd8cz6omu9hh"><span class="c43">std::unordered_multiset</span></h3><p class="c1"><span class="c32">std::unordered_multiset</span><span class="c46">&nbsp;is an associative container that contains set of possibly non-unique objects of type Key.</span></p><h3 class="c59 c52" id="h.aj9hzzeagof7"><span class="c43">std::unordered_multimap</span></h3><p class="c1"><span class="c32">std::unordered_multimap</span><span class="c46">&nbsp;is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. </span></p><h3 class="c49 c63 c52" id="h.nlfupb97lyt3"><span class="c75 c57 c101">Thread safety</span></h3><ol class="c42 lst-kix_jqtponp32vkl-0 start" start="1"><li class="c5 li-bullet-0"><h2 id="h.97hh5j6wa69n" style="display:inline"><span class="c37">All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.</span></h2></li><li class="c5 li-bullet-0"><h2 id="h.97hh5j6wa69n-6" style="display:inline"><span class="c50">All </span><span class="c54 c50">const</span><span class="c50">&nbsp;member functions can be called concurrently by different threads on the same container. In addition, the member functions </span><span class="c83 c54">begin()</span><span class="c50">, </span><span class="c54 c83">end()</span><span class="c50">, </span><span class="c83 c54">rbegin()</span><span class="c50">, </span><span class="c83 c54">rend()</span><span class="c50">, </span><span class="c83 c54">front()</span><span class="c50">, </span><span class="c83 c54">back()</span><span class="c50">, </span><span class="c83 c54">data()</span><span class="c50">, </span><span class="c83 c54">find()</span><span class="c50">, </span><span class="c83 c54">lower_bound()</span><span class="c50">, </span><span class="c83 c54">upper_bound()</span><span class="c50">, </span><span class="c83 c54">equal_range()</span><span class="c50">, </span><span class="c83 c54">at()</span><span class="c50">, and, except in associative containers, </span><span class="c83 c54">operator[]</span><span class="c50">, behave as </span><span class="c54 c50">const</span><span class="c37">&nbsp;for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function&#39;s non-const arguments, including the this pointer.</span></h2></li><li class="c5 li-bullet-0"><h2 id="h.97hh5j6wa69n-7" style="display:inline"><span class="c50">Different elements in the same container can be modified concurrently by different threads, except for the elements of </span><span class="c54 c50">std::vector&lt;bool&gt;</span><span class="c50">&nbsp;(for example, a vector of </span><span class="c18"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/thread/future&amp;sa=D&amp;source=editors&amp;ust=1712175539024895&amp;usg=AOvVaw02lwYqt5-PTBdK_ua-VNQE">std::future</a></span><span class="c37">&nbsp;objects can be receiving values from multiple threads).</span></h2></li><li class="c5 li-bullet-0"><h2 id="h.97hh5j6wa69n-8" style="display:inline"><span class="c37">Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, and may be executed concurrently with operations on other iterators on the same container, with the const member functions, or reads from the elements. Container operations that invalidate any iterators modify the container and cannot be executed concurrently with any operations on existing iterators even if those iterators are not invalidated.</span></h2></li><li class="c5 li-bullet-0"><h2 id="h.97hh5j6wa69n-9" style="display:inline"><span class="c37">Elements of the same container can be modified concurrently with those member functions that are not specified to access these elements. More generally, the C++ standard library functions do not read objects indirectly accessible through their arguments (including other elements of a container) except when required by its specification.</span></h2></li><li class="c5 li-bullet-0"><h2 id="h.gsk051oqkywm" style="display:inline"><span class="c50">In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. </span><span class="c18"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/algorithm/transform&amp;sa=D&amp;source=editors&amp;ust=1712175539025377&amp;usg=AOvVaw0hk0rFW4JBa6ZgNXto7Aeo">std::transform</a></span><span class="c50">&nbsp;may be parallelized, but not </span><span class="c18"><a class="c12" href="https://www.google.com/url?q=https://en.cppreference.com/w/cpp/algorithm/for_each&amp;sa=D&amp;source=editors&amp;ust=1712175539025580&amp;usg=AOvVaw1PlKC9OdeK1iWBrRSrB3XN">std::for_each</a></span><span class="c50">&nbsp;which is specified to visit each element of a sequence in order).</span></h2></li></ol><h2 class="c48" id="h.wljcro5rxihy"><span class="c62 c57">Algorithms</span></h2><p class="c67 c52"><span class="c84 c81">If you use raw loops and you understand the containers, you don&rsquo;t have to deal with these. A surprising &ldquo;advantage&rdquo; of using raw loops - </span><span class="c84 c94"><a class="c12" href="https://www.google.com/url?q=https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms&amp;sa=D&amp;source=editors&amp;ust=1712175539026081&amp;usg=AOvVaw08UKZLgx0OTH8w2vXVIfNQ">please, prefer algorithms</a></span><span class="c36">!</span></p><p class="c67 c52"><span class="c36">Otherwise, most probably you understand what standard algorithms do. Think about them and you&rsquo;ll be able to come up with their complexities in most cases. Let&rsquo;s have a look at some algorithms:</span></p><ul class="c42 lst-kix_9j89h9h47smr-0 start"><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">all_of</span><span class="c22">/ </span><span class="c30">any_of</span><span class="c22">&nbsp;/ </span><span class="c30">none_of</span><span class="c22">&nbsp;have at most </span><span class="c30">O(n)</span><span class="c22">&nbsp;complexity where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the range the algorithm is applied on</span></li><li class="c19 c47 c52 c67 li-bullet-0"><span class="c30">count_if</span><span class="c22">&nbsp;has a complexity of </span><span class="c30">O(n)</span><span class="c22">&nbsp;where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the range the algorithm is applied on</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">find</span><span class="c22">&nbsp;/ </span><span class="c30">find_if</span><span class="c22">&nbsp;have a complexity of </span><span class="c30">O(n)</span><span class="c22">. They need at most </span><span class="c30">n</span><span class="c22">&nbsp;applications of </span><span class="c30">operator==</span><span class="c22">&nbsp;or a predicate where </span><span class="c30">n</span><span class="c10">&nbsp;is the length of the range passed in</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">replace</span><span class="c22">&nbsp;/ </span><span class="c30">replace_if</span><span class="c22">&nbsp;have a complexity of </span><span class="c30">O(n)</span><span class="c22">. They need </span><span class="c30">n</span><span class="c22">&nbsp;applications of </span><span class="c30">operator==</span><span class="c22">&nbsp;or of a predicate where </span><span class="c30">n</span><span class="c22">&nbsp;is the length of the range passed in and at most </span><span class="c30">n</span><span class="c10">&nbsp;assignments</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">copy</span><span class="c22">&nbsp;/ </span><span class="c30">copy_if</span><span class="c22">&nbsp;have a complexity of </span><span class="c30">O(n)</span><span class="c22">. </span><span class="c30">copy</span><span class="c22">&nbsp;does </span><span class="c30">n</span><span class="c22">&nbsp;assignments where </span><span class="c30">n</span><span class="c22">&nbsp;is the length of the passed-in range, for </span><span class="c30">copy_if</span><span class="c10">&nbsp;we also have to think about the application of the predicate, while the number of assignments might be smaller.</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">transform</span><span class="c22">&nbsp;also has a complexity of </span><span class="c30">O(n)</span><span class="c22">. It performs exactly </span><span class="c30">n</span><span class="c22">&nbsp;applications of the operation, where </span><span class="c30">n</span><span class="c10">&nbsp;is the length of the passed-in range.</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">generate</span><span class="c22">&nbsp;has a complexity of </span><span class="c30">O(n)</span><span class="c22">&nbsp;as it invokes </span><span class="c30">n</span><span class="c10">&nbsp;times the generator function and also performs the same amount of assignments.</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">remove_if</span><span class="c22">&nbsp;has a complexity of </span><span class="c30">O(n)</span><span class="c22">&nbsp;as it performs </span><span class="c30">n</span><span class="c22">&nbsp;applications of </span><span class="c30">operator==</span><span class="c22">&nbsp;or of a predicate where </span><span class="c30">n</span><span class="c10">&nbsp;is the length of the range passed in.</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">swap</span><span class="c22">&nbsp;has a complexity of </span><span class="c30">O(1)</span><span class="c22">&nbsp;if applied on single values and </span><span class="c30">O(n)</span><span class="c22">&nbsp;if applied on arrays where </span><span class="c30">n</span><span class="c10">&nbsp;is the size of the arrays to be swapped</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">reverse</span><span class="c22">&nbsp;performs exactly half as many swaps as the size of the range to be reversed, therefore the complexity is </span><span class="c30 c57">O(n)</span></li><li class="c67 c19 c47 c52 li-bullet-0"><span class="c30">rotate</span><span class="c22">&nbsp;also has a complexity of </span><span class="c30">O(n)</span><span class="c10">.</span></li></ul><p class="c67 c52"><span class="c36">Quite boring, right? But boredom brings simplicity to your calculations.</span></p><h2 class="c33" id="h.k1qh1fp8ugy6"><span class="c45">adjacent_find</span></h2><p class="c1"><span class="c23">Searches for two adjacent elements that are either equal or satisfy a specified condition.</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c3">// alg_adj_fnd.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc</span></p><p class="c1"><span class="c20">#include &lt;list&gt;</span></p><p class="c1"><span class="c20">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// Returns whether second element is twice the first</span></p><p class="c1"><span class="c11">bool</span><span class="c9">&nbsp;</span><span class="c20">twice</span><span class="c9">&nbsp;(</span><span class="c11">int</span><span class="c9">&nbsp;elem1, </span><span class="c11">int</span><span class="c0">&nbsp;elem2 )</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">return</span><span class="c0">&nbsp;elem1 * 2 == elem2;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; L;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::iterator Iter;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::iterator result1, result2;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; L.push_back( 50 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; L.push_back( 40 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; L.push_back( 10 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; L.push_back( 20 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; L.push_back( 20 );</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; result2 = </span><span class="c25 c57">adjacent_find( L.begin( ), L.end( ), twice );</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">if</span><span class="c0">&nbsp;( result2 == L.end( ) )</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;There are not two adjacent elements where the &quot;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; </span><span class="c38 c58">&quot;second is twice the first.&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">else</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;There are two adjacent elements where &quot;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; </span><span class="c38 c58">&quot;the second is twice the first.\n&quot;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; </span><span class="c38 c58">&quot;They have values of &quot;</span><span class="c0">&nbsp;&lt;&lt; *(result2++)</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; </span><span class="c38 c58">&quot; &amp; &quot;</span><span class="c9">&nbsp;&lt;&lt; *result2 &lt;&lt; </span><span class="c38 c58">&quot;.&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.ssrgi6s908t1"><span class="c24">all_of</span></h2><p class="c49 c1 c47 c52"><span class="c26">Returns </span><span class="c14 c78">true</span><span class="c40 c26">&nbsp;when a condition is present at each element in the given range.</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; li { 50, 40, 10, 20, 20 };</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::iterator iter;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;li = ( &quot;</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">for</span><span class="c0">&nbsp;(iter = li.begin(); iter != li.end(); iter++)</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; *iter &lt;&lt; </span><span class="c38 c58">&quot; &quot;</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;)&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Check if all elements in li are even.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c54 c58 c68">auto</span><span class="c25">&nbsp;is_even = [](</span><span class="c54 c68 c58">int</span><span class="c25">&nbsp;elem){ </span><span class="c54 c68 c58">return</span><span class="c25 c57">&nbsp;!(elem % 2); };</span></p><p class="c1"><span class="c25">&nbsp; &nbsp; </span><span class="c54 c68 c58">if</span><span class="c25 c57">&nbsp;(all_of(li.begin(), li.end(), is_even))</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;All the elements are even numbers.\n&quot;</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">else</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;Not all the elements are even numbers.\n&quot;</span><span class="c0">;</span></p><p class="c1"><span class="c9">}</span></p><p class="c1 c4"><span class="c23"></span></p><h2 class="c33" id="h.kmc9vbhthh6u"><span class="c45">any_of</span></h2><p class="c49 c1 c47 c52"><span class="c79">Returns </span><span class="c54 c66">true</span><span class="c40 c79">&nbsp;when a condition is present at least once in the specified range of elements.</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Check if there&#39;s an even element in li.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;is_even = [](</span><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c11">const</span><span class="c9">&nbsp;elem){ </span><span class="c11">return</span><span class="c0">&nbsp;!(elem % 2); };</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">if</span><span class="c0">&nbsp;(any_of(li.begin(), li.end(), is_even))</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;There&#39;s an even element in li.\n&quot;</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.iejs7wf2uxuf"><span class="c24">binary_search</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Tests whether there&#39;s an element in a sorted range that is equal to a specified value or that is equivalent to it in a sense specified by a binary predicate.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; List1;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.push_back( 50 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.push_back( 10 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.push_back( 30 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.push_back( 20 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.push_back( 25 );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.push_back( 5 );</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; List1.sort();</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// default binary search for 10</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">if</span><span class="c0">&nbsp;( binary_search(List1.begin(), List1.end(), 10) )</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;There is an element in list with a value equal to 10.&quot;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><h2 class="c33 c98" id="h.ldgu8wrqv8qh"><span class="c45">copy</span></h2><h3 class="c49 c1 c47 c52 c98" id="h.mrnqghr752ak"><span class="c40 c79">Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a forward direction.</span></h3><p class="c1"><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; v1, v2; //v2 has 11 elements</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">// To copy the first 3 elements of v1 into the middle of v2</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; copy( v1.begin( ), v1.begin( ) + 3, v2.begin( ) + 4 );</span></p><h2 class="c33 c98" id="h.pna2e834kazj"><span class="c45">copy_backward</span></h2><h3 class="c49 c1 c47 c52 c98" id="h.1321du7i27p"><span class="c40 c79">Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a backward direction.</span></h3><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// To copy_backward the first 3 elements of v1 into the middle of v2</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; copy_backward( v1.begin( ), v1.begin( ) + 3, v2.begin( ) + 7 );</span></p><p class="c1 c4"><span class="c23"></span></p><h2 class="c33" id="h.c5uy636d8tsr"><span class="c45">copy_if</span></h2><p class="c49 c1 c47 c52"><span class="c79">In a range of elements, copies the elements that are </span><span class="c54 c66">true</span><span class="c40 c79">&nbsp;for the specified condition.</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; li{ 46, 59, 88, 72, 79, 71, 60, 5, 40, 84 };</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c9">&gt; lo(li.size()); </span><span class="c3">// lo = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// is_odd checks if the element is odd.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;is_odd = [](</span><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c11">const</span><span class="c9">&nbsp;elem) { </span><span class="c11">return</span><span class="c0">&nbsp;(elem % 2); };</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// use copy_if to select only odd elements from li</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// and copy them to lo, starting from lo&#39;s begin position</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c0">&nbsp;oc = copy_if(li.begin(), li.end(), lo.begin(), is_odd);</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; lo.resize(</span><span class="c11">std</span><span class="c9">::distance(lo.begin(), oc)); &nbsp;</span><span class="c3">// shrink lo to new size</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1 c4"><span class="c23"></span></p><h2 class="c33" id="h.j637ewyyiwua"><span class="c45">copy_n</span></h2><p class="c49 c1 c47 c52"><span class="c40 c79">Copies a specified number of elements.</span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">string</span><span class="c9">&nbsp;s1{</span><span class="c38 c58">&quot;dandelion&quot;</span><span class="c0">};</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">string</span><span class="c9">&nbsp;s2{</span><span class="c38 c58">&quot;badger&quot;</span><span class="c0">};</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; s1 &lt;&lt; </span><span class="c38 c58">&quot; + &quot;</span><span class="c9">&nbsp;&lt;&lt; s2 &lt;&lt; </span><span class="c38 c58">&quot; = &quot;</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Copy the first 3 letters from s1</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// to the first 3 positions in s2</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; copy_n(s1.begin(), 3, s2.begin());</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; s2 &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.htuvclegs369"><span class="c24">count</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Returns the number of elements in a range whose values match a specified value.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::iterator::difference_type result;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; result = count(v1.begin(), v1.end(), 10);</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;The number of 10s in v2 is: &quot;</span><span class="c9">&nbsp;&lt;&lt; result &lt;&lt; </span><span class="c38 c58">&quot;.&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1 c4"><span class="c23"></span></p><h2 class="c33" id="h.efkdq7i5quvi"><span class="c45">count_if</span></h2><p class="c49 c1 c47 c52"><span class="c40 c79">Returns the number of elements in a range whose values satisfy a specified condition.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; vector&lt;int&gt;::iterator::difference_type result1;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; result1 = count_if(v1.begin(), v1.end(), </span><span class="c25">[](auto x) {return x &gt; 10;}</span><span class="c0">);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; cout &lt;&lt; &quot;The number of elements in v1 greater than 10 is: &quot;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; result1 &lt;&lt; &quot;.&quot; &lt;&lt; endl;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c23"></span></p><h2 class="c33" id="h.9z7usbuab3i1"><span class="c45">equal</span></h2><p class="c49 c1 c47 c52"><span class="c40 c79">Compares two ranges element by element for equality or equivalence in a sense specified by a binary predicate.</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c0">bool &nbsp; b = equal(v1.begin(), v1.end(), v3.begin(), v3.end());</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.asjvhr13o7j"><span class="c45">fill</span></h2><p class="c49 c1 c47 c52"><span class="c40 c79">Assigns the same new value to every element in a specified range.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Fill the last 5 positions with a value of 2</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; fill( v1.begin( ) + 5, v1.end( ), 2 );</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.z3rrdb8xwt1q"><span class="c24">fill_n</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Assigns a new value to a specified number of elements in a range beginning with a particular element.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Fill the first 3 positions with a value of 1, saving position.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c0">&nbsp;pos = fill_n( v.begin(), 3, 1 );</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.xn7kc0d4fwrx"><span class="c24">find</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Locates the position of the first occurrence of an element in a range that has a specified value.</span></p><h2 class="c33" id="h.rg0bwpex3fib"><span class="c24">find_first_of</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Searches for the first occurrence of any of several values within a target range.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Searching v1 for a match to L1 under the binary predicate twice</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::iterator result2;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; v1, v2;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; result2 = find_first_of ( v1.begin( ), v1.end( ), v2.begin( ),</span></p><p class="c1 c124"><span class="c0">&nbsp;v2.end(), twice );</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// Return whether second element is twice the first</span></p><p class="c1"><span class="c11">bool</span><span class="c9">&nbsp;</span><span class="c20">twice</span><span class="c9">&nbsp;( </span><span class="c11">int</span><span class="c9">&nbsp;elem1, </span><span class="c11">int</span><span class="c0">&nbsp;elem2 )</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">return</span><span class="c0">&nbsp;2 * elem1 == elem2;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.vfub8pddghmx"><span class="c24">find_if</span></h2><p class="c1"><span class="c40 c27">Locates the position of the first occurrence of an element in a range that satisfies a specified condition.</span></p><p class="c1"><span class="c3">// Function to use as the UnaryPredicate argument to find_if() in this example</span></p><p class="c1"><span class="c11">bool</span><span class="c9">&nbsp;</span><span class="c20">is_odd_int</span><span class="c9">(</span><span class="c11">int</span><span class="c0">&nbsp;i) {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">return</span><span class="c0">&nbsp;((i % 2) != 0);</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// call &lt;algorithm&gt; std::find_if()</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;p = find_if(first, last, </span><span class="c20">is_odd_int</span><span class="c9">);</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.9kqnl9fekf76"><span class="c24">for_each</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Applies a specified function object to each element in a forward order within a range and returns the function object.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">#include &lt;vector&gt;</span></p><p class="c1"><span class="c0">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c0">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">// The function object multiplies an element by a Factor</span></p><p class="c1"><span class="c0">template &lt;class Type&gt;</span></p><p class="c1"><span class="c0">class MultValue</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">private:</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Type Factor; &nbsp; // The value to multiply by</span></p><p class="c1"><span class="c0">public:</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; // Constructor initializes the value to multiply by</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; MultValue ( const Type&amp; value ) : Factor ( value ) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; // The function call for the element to be multiplied</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; void operator( ) ( Type&amp; elem ) const</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; elem *= Factor;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">};</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">int main()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; using namespace std;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; vector&lt;int&gt; v1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; vector&lt;int&gt;::iterator Iter1;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; // Constructing vector v1</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; int i;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for ( i = -4 ; i &lt;= 2 ; i++ )</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; v1.push_back( i );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; cout &lt;&lt; &quot;Original vector v1 = ( &quot; ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; // Using for_each to multiply each element by a Factor</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //for_each ( v1.begin( ), v1.end( ), MultValue&lt;int&gt; ( -2 ) );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for_each ( v1.begin( ), v1.end( ), [](int&amp; k) { k = k * -2;} );</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; cout &lt;&lt; &quot;Multiplying the elements of the vector v1\n &quot;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; &quot;by the factor -2 gives:\n v1mod1 = ( &quot; ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">/*</span></p><p class="c1"><span class="c0">Original vector v1 = ( -4 -3 -2 -1 0 1 2 ).</span></p><p class="c1"><span class="c0">Multiplying the elements of the vector v1</span></p><p class="c1"><span class="c0">&nbsp;by the factor -2 gives:</span></p><p class="c1"><span class="c0">&nbsp;v1mod1 = ( 8 6 4 2 0 -2 -4 ).</span></p><p class="c1"><span class="c0">*/</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.qqt50yfc66mb"><span class="c24">generate</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Assigns the values generated by a function object to each element in a range.</span></p><p class="c1"><span class="c40 c27">The function object is invoked for each element in the range and doesn&#39;t need to return the same value each time it&#39;s called. It is called with no arguments to generate the values to be assigned to each of the elements in the range.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c20">#include &lt;vector&gt;</span></p><p class="c1"><span class="c20">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Assigning random values to vector integer elements</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; v1 ( 5 );</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::iterator Iter1;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; generate ( v1.begin( ), v1.end( ), rand );</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;Vector v1 is ( &quot;</span><span class="c0">&nbsp;;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">for</span><span class="c0">&nbsp;( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; *Iter1 &lt;&lt; </span><span class="c38 c58">&quot; &quot;</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;).&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c9">}</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.l7f1se2vclvp"><span class="c24">is_sorted</span></h2><p class="c49 c1 c47 c52"><span class="c26">Returns </span><span class="c14 c78">true</span><span class="c26 c40">&nbsp;if the elements in the specified range are in sorted order.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.8hq5noy60kwe"><span class="c24">remove</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Eliminates a specified value from a given range without disturbing the order of the remaining elements. Returns the end of a new range free of the specified value.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Remove elements with a value of 7</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; auto new_end = remove ( v1.begin( ), v1.end( ), 7 );</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// To change the sequence size, use erase</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; v1.erase (new_end, v1.end( ) );</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Always use erase() after remove() to resize.</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.c2tvug45xcre"><span class="c24">replace/replace_if</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Examines each element in a range and replaces it if it matches a specified value.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c58 c80 c90 c110">replace_if</span><span class="c0">(v.begin(), v.end(), [](int k){ return k &gt; 6; }, 70);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.jpwuqg6b7qdq"><span class="c24">reverse</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Reverses the order of the elements within a range.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Reverse the elements in the vector</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; reverse (v1.begin( ), v1.end( ) );</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.3tasrmtvft0m"><span class="c24">sort</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// To sort in descending order. specify binary predicate</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; sort( v1.begin( ), v1.end( ), </span><span class="c87 c58 c80">greater&lt;</span><span class="c87 c58 c108">int</span><span class="c58 c80 c87">&gt;( )</span><span class="c0">&nbsp;);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// Return whether first element is greater than the second</span></p><p class="c1"><span class="c11">bool</span><span class="c9">&nbsp;</span><span class="c20">UDgreater</span><span class="c9">&nbsp;( </span><span class="c11">int</span><span class="c9">&nbsp;elem1, </span><span class="c11">int</span><span class="c0">&nbsp;elem2 )</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">return</span><span class="c0">&nbsp;elem1 &gt; elem2;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3 c57">// A user-defined (UD) binary predicate can also be used</span></p><p class="c1"><span class="c3 c57">&nbsp; &nbsp; //sorts in Desc order as above</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; sort( v1.begin( ), v1.end( ), </span><span class="c110 c58 c80 c90">UDgreater</span><span class="c0">&nbsp;);</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.l9rvn76465zn"><span class="c24">swap</span></h2><p class="c49 c1 c47 c52"><span class="c26">This exchanges the values of two objects. = </span><span class="c87 c58 c80">swap( v1, v2 );</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.moc1k8p1ufwe"><span class="c24">transform</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Applies a specified function object to each element in a source range or to a pair of elements from two source ranges. Then, it copies the return values of the function object into a destination range.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Using transform to multiply each element by a factor of 5</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; transform ( v1.begin( ), v1.end( ), v2.begin( ), MultValue&lt;</span><span class="c11">int</span><span class="c0">&gt; ( 5 ) );</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c33" id="h.kota8ui78r1x"><span class="c24">unique</span></h2><p class="c49 c1 c47 c52"><span class="c40 c26">Removes duplicate elements that are next to each other in a specified range.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1 c4"><span class="c23"></span></p><h3 class="c71 c74" id="h.bq95th3zkjfm"><span class="c31"></span></h3><h3 class="c74 c71" id="h.3pq9bjmecgl1"><span class="c31"></span></h3><h3 class="c74 c71" id="h.25z32hskpfu9"><span class="c31"></span></h3><h3 class="c74 c71" id="h.itubawjwwryw"><span class="c31"></span></h3><h3 class="c74 c71" id="h.18o35pwxyshd"><span class="c31"></span></h3><p class="c67 c4 c52"><span class="c36"></span></p><h2 class="c48" id="h.lrfxx839dajy"><span class="c57 c76">Conclusion</span></h2><p class="c67 c52"><span class="c36">In this article, we talked about the complexity analysis of operations on containers and of algorithms which are so often make important part of a software developer job interview. We discussed some hints on how to approach such questions if you neglected complexity analysis during most of your preparation for interviews. Finally, we quickly went through the most important complexities of C++ containers and standard algorithms so that you can have the most basic characteristics that you&rsquo;d need at a job interview. Good luck!</span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span class="c23">Lambdas</span></p><p class="c1"><span class="c69"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712175539053041&amp;usg=AOvVaw2QPd-jUKkygZJP9FZ1Iavw">https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170</a></span></p><p class="c1 c4"><span class="c23"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 295.00px; height: 205.00px;"><img alt="" src="images/image1.png" style="width: 295.00px; height: 205.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c23"></span></p><ol class="c42 lst-kix_1c8d1l2jxfms-0 start" start="1"><li class="c39 c1 c82 c47 li-bullet-0"><span class="c34">capture clause</span><span class="c79">&nbsp;(Also known as the </span><span class="c34">lambda-introducer</span><span class="c40 c79">&nbsp;in the C++ specification.) [&amp;, =]</span></li><li class="c39 c1 c82 c47 li-bullet-0"><span class="c34">parameter list</span><span class="c79">&nbsp;Optional. (Also known as the </span><span class="c34">lambda declarator</span><span class="c40 c79">)</span></li><li class="c39 c1 c82 c47 li-bullet-0"><span class="c34">mutable specification</span><span class="c40 c79">&nbsp;Optional.</span></li><li class="c39 c1 c47 c82 li-bullet-0"><span class="c34">exception-specification</span><span class="c40 c79">&nbsp;Optional.</span></li><li class="c39 c1 c82 c47 li-bullet-0"><span class="c34">trailing-return-type</span><span class="c40 c79">&nbsp;Optional.</span></li><li class="c39 c1 c82 c47 li-bullet-0"><span class="c34">lambda body</span><span class="c40 c79">.</span></li></ol><p class="c1"><span class="c11">struct</span><span class="c9">&nbsp;</span><span class="c20">S</span><span class="c9">&nbsp;{ </span><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">f</span><span class="c9">(</span><span class="c11">int</span><span class="c0">&nbsp;i); };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">void</span><span class="c9">&nbsp;S::f(</span><span class="c11">int</span><span class="c0">&nbsp;i) {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; [&amp;, i]{}; &nbsp; &nbsp; &nbsp;</span><span class="c3">// OK</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; [&amp;, &amp;i]{}; &nbsp; &nbsp; </span><span class="c3">// ERROR: i preceded by &amp; when &amp; is the default</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; [=, </span><span class="c11">this</span><span class="c9">]{}; &nbsp; </span><span class="c3">// ERROR: this when = is the default</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; [=, *</span><span class="c11">this</span><span class="c9">]{ }; </span><span class="c3">// OK: captures this by value. See below.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; [i, i]{}; &nbsp; &nbsp; &nbsp;</span><span class="c3">// ERROR: i repeated</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c49 c1 c47 c52"><span class="c26">A capture followed by an ellipsis is a pack expansion, as shown in this </span><span class="c93 c97"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/cpp/ellipses-and-variadic-templates?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712175539055175&amp;usg=AOvVaw3G6SxbuOSF6SJ6g3xT8deK">variadic template</a></span><span class="c40 c26">&nbsp;example:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">template</span><span class="c9">&lt;</span><span class="c11">class</span><span class="c9">... </span><span class="c20">Args</span><span class="c0">&gt;</span></p><p class="c1"><span class="c20">void</span><span class="c9">&nbsp;</span><span class="c20">f</span><span class="c9">(</span><span class="c20">Args</span><span class="c9">... </span><span class="c20">args</span><span class="c0">) {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;x = [args...] { </span><span class="c11">return</span><span class="c0">&nbsp;g(args...); };</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; x();</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c27">To use lambda expressions in the body of a class member function, pass the </span><span class="c7">this</span><span class="c40 c27">&nbsp;pointer to the capture clause to provide access to the member functions and data members of the enclosing class.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c49 c1 c47 c52"><span class="c40 c27">When you use the capture clause, we recommend that you keep these points in mind, particularly when you use lambdas with multi-threading:</span></p><ul class="c42 lst-kix_6bxb5fjs3xf-0 start"><li class="c39 c1 c82 c47 li-bullet-0"><span class="c27">Reference captures can be used to modify variables outside, but value captures can&#39;t. (</span><span class="c7">mutable</span><span class="c40 c27">&nbsp;allows copies to be modified, but not originals.)</span></li><li class="c39 c1 c82 c47 li-bullet-0"><span class="c40 c27">Reference captures reflect updates to variables outside, but value captures don&#39;t.</span></li><li class="c39 c1 c82 c47 li-bullet-0"><span class="c40 c27">Reference captures introduce a lifetime dependency, but value captures have no lifetime dependencies. It&#39;s especially important when the lambda runs asynchronously. If you capture a local by reference in an async lambda, that local could easily be gone by the time the lambda runs. Your code could cause an access violation at run time.</span></li></ul><h3 class="c33" id="h.bd4re33a8loy"><span class="c57 c80 c90 c52 c120">Generalized capture (C++14)</span></h3><p class="c49 c1 c47 c52"><span class="c27">In C++14, you can introduce and initialize new variables in the capture clause, without the need to have those variables exist in the lambda function&#39;s enclosing scope. The initialization can be expressed as any arbitrary expression; the type of the new variable is deduced from the type produced by the expression. This feature lets you capture move-only variables (such as </span><span class="c7">std::unique_ptr</span><span class="c40 c27">) from the surrounding scope and use them in a lambda.</span></p><p class="c39 c1"><span class="c40 c27">C++</span></p><p class="c39 c1"><span class="c40 c46 c80">Copy</span></p><p class="c39 c1"><span class="c54 c80 c52">pNums = make_unique&lt;</span><span class="c17">vector</span><span class="c54 c80 c52">&lt;</span><span class="c17">int</span><span class="c57 c54 c64 c52">&gt;&gt;(nums);</span></p><p class="c39 c1"><span class="c54 c116 c52">//...</span></p><p class="c1 c39"><span class="c54 c80 c52">&nbsp; &nbsp; &nbsp; </span><span class="c17">auto</span><span class="c57 c54 c64 c52">&nbsp;a = [ptr = move(pNums)]()</span></p><p class="c39 c1"><span class="c57 c54 c52 c64">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c39 c1"><span class="c54 c80 c52">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c54 c52 c116">// use ptr</span></p><p class="c39 c107"><span class="c57 c54 c64 c52">&nbsp; &nbsp; &nbsp; &nbsp; };</span></p><p class="c39 c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c40 c27">Examples:</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// declaring_lambda_expressions1.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;functional&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Assign the lambda expression that adds two numbers to an auto variable.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;f1 = [](</span><span class="c11">int</span><span class="c9">&nbsp;x, </span><span class="c11">int</span><span class="c9">&nbsp;y) { </span><span class="c11">return</span><span class="c0">&nbsp;x + y; };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; f1(2, 3) &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Assign the same lambda expression to a function object.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; function&lt;</span><span class="c11">int</span><span class="c9">(</span><span class="c11">int</span><span class="c9">, </span><span class="c11">int</span><span class="c9">)&gt; f2 = [](</span><span class="c11">int</span><span class="c9">&nbsp;x, </span><span class="c11">int</span><span class="c9">&nbsp;y) { </span><span class="c11">return</span><span class="c0">&nbsp;x + y; };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; f2(3, 4) &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c40 c27">The Microsoft C++ compiler binds a lambda expression to its captured variables when the expression is declared instead of when the expression is called. </span></p><p class="c1"><span class="c3">// declaring_lambda_expressions2.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;functional&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">int</span><span class="c0">&nbsp;i = 3;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">int</span><span class="c0">&nbsp;j = 5;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// The following lambda expression captures i by value and</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// j by reference.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;function&lt;</span><span class="c11">int</span><span class="c9">&nbsp;(</span><span class="c11">void</span><span class="c9">)&gt; f = [i, &amp;j] { </span><span class="c11">return</span><span class="c0">&nbsp;i + j; };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Change the values of i and j.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;i = 22;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;j = 44;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c3">// Call f and print its result.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; f() &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Output is: 47 &lt;&lt;&lt;&lt; 3 + 44</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c27">This example declares a lambda expression that returns the sum of two integers and calls the expression immediately with the arguments </span><span class="c14 c78">5</span><span class="c27">&nbsp;and </span><span class="c14 c78">4</span><span class="c40 c27">:</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// calling_lambda_expressions1.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">int</span><span class="c9">&nbsp;n = [] (</span><span class="c11">int</span><span class="c9">&nbsp;x, </span><span class="c11">int</span><span class="c9">&nbsp;y) { </span><span class="c11">return</span><span class="c0">&nbsp;x + y; }(5, 4);</span></p><p class="c1"><span class="c9">&nbsp; &nbsp;</span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; n &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c27">This example passes a lambda expression as an argument to the </span><span class="c14 c78">find_if</span><span class="c27">&nbsp;function. The lambda expression returns </span><span class="c7">true</span><span class="c27">&nbsp;if its parameter is an even number.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// calling_lambda_expressions2.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;list&gt;</span></p><p class="c1"><span class="c20">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Create a list of integers with a few initial elements.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; numbers;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; numbers.push_back(13);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; numbers.push_back(17);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; numbers.push_back(42);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; numbers.push_back(46);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; numbers.push_back(99);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Use the find_if function and a lambda expression to find the</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// first even number in the list.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">const</span><span class="c9">&nbsp;</span><span class="c11">list</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt;::const_iterator result =</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; find_if(numbers.begin(), numbers.end(),[](</span><span class="c11">int</span><span class="c9">&nbsp;n) { </span><span class="c11">return</span><span class="c0">&nbsp;(n % 2) == 0; });</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Print the result.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">if</span><span class="c0">&nbsp;(result != numbers.end()) {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;The first even number in the list is &quot;</span><span class="c9">&nbsp;&lt;&lt; *result &lt;&lt; </span><span class="c38 c58">&quot;.&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; } </span><span class="c11">else</span><span class="c0">&nbsp;{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;The list contains no even numbers.&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Output: The first even number in the list is 42.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c40 c27">Nested Lambda: You can nest a lambda expression inside another one, as shown in this example. The inner lambda expression multiplies its argument by 2 and returns the result. The outer lambda expression calls the inner lambda expression with its argument and adds 3 to the result.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// nesting_lambda_expressions.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The following lambda expression contains a nested lambda</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// expression.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">int</span><span class="c9">&nbsp;timestwoplusthree = [](</span><span class="c11">int</span><span class="c9">&nbsp;x) { </span><span class="c11">return</span><span class="c9">&nbsp;</span><span class="c25">[](</span><span class="c54 c68 c58">int</span><span class="c25">&nbsp;y) { </span><span class="c54 c68 c58">return</span><span class="c25">&nbsp;y * 2; }</span><span class="c0">(x) + 3; }(5);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Print the result.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; timestwoplusthree &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">Higher order Lambda Functions: </span><span class="c27">Many programming languages support the concept of a </span><span class="c34 c52">higher-order function.</span><span class="c27">&nbsp;A higher-order function is a lambda expression that takes another lambda expression as its argument or returns a lambda expression. You can use the </span><span class="c97 c52 c125"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/standard-library/function-class?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712175539065731&amp;usg=AOvVaw2vYdU8j-iNuEVP7KwQPi0V">function</a></span><span class="c27">&nbsp;class to enable a C++ lambda expression to behave like a higher-order function. The following example shows a lambda expression that returns a </span><span class="c14 c78">function</span><span class="c27">&nbsp;object and a lambda expression that takes a </span><span class="c14 c78">function</span><span class="c40 c27">&nbsp;object as its argument.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// higher_order_lambda_expression.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c20">#include &lt;functional&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The following code declares a lambda expression that returns</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// another lambda expression that adds two numbers.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The returned lambda expression captures parameter x by value.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;addtwointegers = [](</span><span class="c11">int</span><span class="c9">&nbsp;x) -&gt; function&lt;</span><span class="c11">int</span><span class="c9">(</span><span class="c11">int</span><span class="c0">)&gt; {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">return</span><span class="c9">&nbsp;[=](</span><span class="c11">int</span><span class="c9">&nbsp;y) { </span><span class="c11">return</span><span class="c0">&nbsp;x + y; };</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The following code declares a lambda expression that takes another</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// lambda expression as its argument.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The lambda expression applies the argument z to the function f</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// and multiplies by 2.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c9">&nbsp;higherorder = [](</span><span class="c11">const</span><span class="c9">&nbsp;function&lt;</span><span class="c11">int</span><span class="c9">(</span><span class="c11">int</span><span class="c9">)&gt;&amp; f, </span><span class="c11">int</span><span class="c0">&nbsp;z) {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">return</span><span class="c0">&nbsp;f(z) * 2;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; };</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Call the lambda expression that is bound to higherorder.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">auto</span><span class="c0">&nbsp;answer = higherorder(addtwointegers(7), 8);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Print the result, which is (7+8)*2.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; answer &lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">Lambda in a Function: </span><span class="c27">You can use lambda expressions in the body of a function. The lambda expression can access any function or data member that the enclosing function can access. You can explicitly or implicitly capture the </span><span class="c7">this</span><span class="c40 c27">&nbsp;pointer to provide access to functions and data members of the enclosing class.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// capture &quot;this&quot; by reference</span></p><p class="c1"><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">ApplyScale</span><span class="c9">(</span><span class="c11">const</span><span class="c9">&nbsp;</span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c9">&gt;&amp; v) </span><span class="c11">const</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;for_each(v.begin(), v.end(),</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; [</span><span class="c11">this</span><span class="c9">](</span><span class="c11">int</span><span class="c9">&nbsp;n) { </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; n * _scale &lt;&lt; </span><span class="c11">endl</span><span class="c0">; });</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// capture &quot;this&quot; by value (Visual Studio 2017 version 15.3 and later)</span></p><p class="c1"><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">ApplyScale2</span><span class="c9">(</span><span class="c11">const</span><span class="c9">&nbsp;</span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c9">&gt;&amp; v) </span><span class="c11">const</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;for_each(v.begin(), v.end(),</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; [*</span><span class="c11">this</span><span class="c9">](</span><span class="c11">int</span><span class="c9">&nbsp;n) { </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; n * _scale &lt;&lt; </span><span class="c11">endl</span><span class="c0">; });</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// capture &quot;this&quot; implicitly</span></p><p class="c1"><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">ApplyScale</span><span class="c9">(</span><span class="c11">const</span><span class="c9">&nbsp;</span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c9">&gt;&amp; v) </span><span class="c11">const</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;for_each(v.begin(), v.end(),</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; [=](</span><span class="c11">int</span><span class="c9">&nbsp;n) { </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; n * _scale &lt;&lt; </span><span class="c11">endl</span><span class="c0">; });</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// function_lambda_expression.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c20">#include &lt;vector&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">class</span><span class="c9">&nbsp;</span><span class="c20">Scale</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c11">public</span><span class="c0">:</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The constructor.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">explicit</span><span class="c9">&nbsp;</span><span class="c20">Scale</span><span class="c9">(</span><span class="c11">int</span><span class="c9">&nbsp;scale) : _</span><span class="c20">scale</span><span class="c0">(scale) {}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Prints the product of each element in a vector object</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// and the scale value to the console.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">ApplyScale</span><span class="c9">(</span><span class="c11">const</span><span class="c9">&nbsp;</span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c9">&gt;&amp; v) </span><span class="c11">const</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; for_each(v.begin(), v.end(), [=](</span><span class="c11">int</span><span class="c9">&nbsp;n) { </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; n * _scale &lt;&lt; </span><span class="c11">endl</span><span class="c0">; });</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">private</span><span class="c0">:</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">int</span><span class="c0">&nbsp;_scale;</span></p><p class="c1"><span class="c0">};</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; values;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; values.push_back(1);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; values.push_back(2);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; values.push_back(3);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; values.push_back(4);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Create a Scale object that scales elements by 3 and apply</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// it to the vector object. Does not modify the vector.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; Scale </span><span class="c20">s</span><span class="c0">(3);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; s.ApplyScale(values);</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">Using Lambda with templates: </span><span class="c27">Because lambda expressions are typed, you can use them with C++ templates. The following example shows the </span><span class="c14 c78">negate_all</span><span class="c27">&nbsp;and </span><span class="c14 c78">print_all</span><span class="c27">&nbsp;functions. The </span><span class="c14 c78">negate_all</span><span class="c27">&nbsp;function applies the unary </span><span class="c7">operator-</span><span class="c27">&nbsp;to each element in the </span><span class="c14 c78">vector</span><span class="c27">&nbsp;object. The </span><span class="c14 c78">print_all</span><span class="c27">&nbsp;function prints each element in the </span><span class="c14 c78">vector</span><span class="c40 c27">&nbsp;object to the console.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// template_lambda_expression.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc</span></p><p class="c1"><span class="c20">#include &lt;vector&gt;</span></p><p class="c1"><span class="c20">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// Negates each element in the vector object. Assumes signed data type.</span></p><p class="c1"><span class="c11">template</span><span class="c9">&nbsp;&lt;</span><span class="c11">typename</span><span class="c0">&nbsp;T&gt;</span></p><p class="c1"><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">negate_all</span><span class="c9">(</span><span class="c11">vector</span><span class="c0">&lt;T&gt;&amp; v)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for_each(v.begin(), v.end(), [](T&amp; n) { n = -n; });</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c3">// Prints to the console each element in the vector object.</span></p><p class="c1"><span class="c11">template</span><span class="c9">&nbsp;&lt;</span><span class="c11">typename</span><span class="c0">&nbsp;T&gt;</span></p><p class="c1"><span class="c11">void</span><span class="c9">&nbsp;</span><span class="c20">print_all</span><span class="c9">(</span><span class="c11">const</span><span class="c9">&nbsp;</span><span class="c11">vector</span><span class="c0">&lt;T&gt;&amp; v)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; for_each(v.begin(), v.end(), [](</span><span class="c11">const</span><span class="c9">&nbsp;T&amp; n) { </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; n &lt;&lt; </span><span class="c11">endl</span><span class="c0">; });</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Create a vector of signed integers with a few elements.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; v;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; v.push_back(34);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; v.push_back(-43);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; v.push_back(56);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; print_all(v);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; negate_all(v);</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">cout</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;After negate_all():&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; print_all(v);</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Output:</span></p><p class="c1"><span class="c0">34</span></p><p class="c1"><span class="c0">-43</span></p><p class="c1"><span class="c0">56</span></p><p class="c1"><span class="c0">After negate_all():</span></p><p class="c1"><span class="c0">-34</span></p><p class="c1"><span class="c0">43</span></p><p class="c1"><span class="c0">-56</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">Handling Exceptions: </span><span class="c27">The body of a lambda expression follows the rules for both structured exception handling (SEH) and C++ exception handling. You can handle a raised exception in the body of a lambda expression or defer exception handling to the enclosing scope. The following example uses the </span><span class="c7">for_each</span><span class="c27">&nbsp;function and a lambda expression to fill a </span><span class="c14 c78">vector</span><span class="c27">&nbsp;object with the values of another one. It uses a </span><span class="c7">try</span><span class="c27">/</span><span class="c7">catch</span><span class="c40 c27">&nbsp;block to handle invalid access to the first vector.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// eh_lambda_expression.cpp</span></p><p class="c1"><span class="c3">// compile with: /EHsc /W4</span></p><p class="c1"><span class="c20">#include &lt;vector&gt;</span></p><p class="c1"><span class="c20">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c20">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c9">&nbsp;</span><span class="c11">std</span><span class="c0">;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Create a vector that contains 3 elements.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; elements(3);</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Create another vector that contains index values.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">vector</span><span class="c9">&lt;</span><span class="c11">int</span><span class="c0">&gt; indices(3);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; indices[0] = 0;</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; indices[1] = -1; </span><span class="c3">// This is not a valid subscript. It will trigger an exception.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; indices[2] = 2;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// Use the values from the vector of index values to</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// fill the elements vector. This example uses a</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// try/catch block to handle invalid access to the</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// elements vector.</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">try</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; for_each(indices.begin(), indices.end(), [&amp;](</span><span class="c11">int</span><span class="c0">&nbsp;index) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elements.at(index) = index;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; });</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">catch</span><span class="c9">&nbsp;(</span><span class="c11">const</span><span class="c0">&nbsp;out_of_range&amp; e)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">cerr</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c38 c58">&quot;Caught &#39;&quot;</span><span class="c9">&nbsp;&lt;&lt; e.what() &lt;&lt; </span><span class="c38 c58">&quot;&#39;.&quot;</span><span class="c9">&nbsp;&lt;&lt; </span><span class="c11">endl</span><span class="c0">;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; };</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">Managed C++/CLI: </span><span class="c27">The capture clause of a lambda expression cannot contain a variable that has a managed type. However, you can pass an argument that has a managed type to the parameter list of a lambda expression. The following example contains a lambda expression that captures the local unmanaged variable </span><span class="c14 c78">ch</span><span class="c27">&nbsp;by value and takes a </span><span class="c97 c94 c52"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/dotnet/api/system.string&amp;sa=D&amp;source=editors&amp;ust=1712175539079218&amp;usg=AOvVaw3bfKr8yy5I_oXgsQLCNvl6">System.String</a></span><span class="c40 c27">&nbsp;object as its parameter.</span></p><p class="c1 c4"><span class="c40 c27"></span></p><p class="c1"><span class="c3">// managed_lambda_expression.cpp</span></p><p class="c1"><span class="c3">// compile with: /clr</span></p><p class="c1"><span class="c11">using</span><span class="c9">&nbsp;</span><span class="c11">namespace</span><span class="c0">&nbsp;System;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c11">int</span><span class="c9">&nbsp;</span><span class="c20">main</span><span class="c0">()</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c11">char</span><span class="c9">&nbsp;ch = </span><span class="c38 c58">&#39;!&#39;</span><span class="c9">; </span><span class="c3">// a local unmanaged variable</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// The following lambda expression captures local variables</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; </span><span class="c3">// by value and takes a managed String object as its parameter.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; [=](String ^s) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Console::WriteLine(s + Convert::ToChar(ch));</span></p><p class="c1"><span class="c9">&nbsp; &nbsp; }(</span><span class="c38 c58">&quot;Hello&quot;</span><span class="c0">);</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c49 c47 c105" id="h.l6drrqv58ubg"><span class="c57 c110 c119 c80 c90">Function Objects vs. Lambdas</span></h2><p class="c49 c1 c47"><span class="c9">When you write code, you probably use function pointers and function objects to solve problems and perform calculations, especially when you use </span><span class="c93 c54 c58"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/standard-library/algorithms?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712175539080685&amp;usg=AOvVaw1FqGEf7LStRXG74FBsGctn">C++ Standard Library algorithms</a></span><span class="c0">. Function pointers and function objects each have advantages and disadvantages&mdash;for example, function pointers have minimal syntactic overhead but do not retain state within a scope, and function objects can maintain state but require the syntactic overhead of a class definition.</span></p><p class="c49 c1 c47"><span class="c0">A lambda combines the benefits of function pointers and function objects and avoids their disadvantages. Like a function object, a lambda is flexible and can maintain state, but unlike a function object, its compact syntax doesn&#39;t require an explicit class definition. By using lambdas, you can write code that&#39;s less cumbersome and less prone to errors than the code for an equivalent function object.</span></p><p class="c1 c47 c49"><span class="c9">The following examples compare the use of a lambda to the use of a function object. The first example uses a lambda to print to the console whether each element in a </span><span class="c56 c54">vector</span><span class="c0">&nbsp;object is even or odd. The second example uses a function object to accomplish the same task.</span></p><h2 class="c49 c95 c47" id="h.mrkf8piq8cfy"><span class="c57 c110 c119 c80 c90">Example 1: Using a Lambda</span></h2><p class="c49 c1 c47"><span class="c9">This example passes a lambda to the for_each function. The lambda prints a result that states whether each element in a </span><span class="c56 c54">vector</span><span class="c0">&nbsp;object is even or odd.</span></p><p class="c86 c4"><span class="c14 c57 c96"></span></p><p class="c1"><span class="c6">// even_lambda.cpp</span></p><p class="c1"><span class="c6">// compile with: cl /EHsc /nologo /W4 /MTd</span></p><p class="c1"><span class="c44">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c44">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c44">#include &lt;vector&gt;</span></p><p class="c1"><span class="c28">using</span><span class="c14">&nbsp;</span><span class="c28">namespace</span><span class="c14">&nbsp;</span><span class="c28">std</span><span class="c2">;</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c28">int</span><span class="c14">&nbsp;</span><span class="c44">main</span><span class="c2">()</span></p><p class="c1"><span class="c2">{</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c6">// Create a vector object that contains 9 elements.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c28">vector</span><span class="c14">&lt;</span><span class="c28">int</span><span class="c2">&gt; v;</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c28">for</span><span class="c14">&nbsp;(</span><span class="c28">int</span><span class="c2">&nbsp;i = 1; i &lt; 10; ++i) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; v.push_back(i);</span></p><p class="c1"><span class="c2">&nbsp; &nbsp;}</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c6">// Count the number of even numbers in the vector by</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c6">// using the for_each function and a lambda.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c28">int</span><span class="c2">&nbsp;evenCount = 0;</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;for_each(v.begin(), v.end(), [&amp;evenCount] (</span><span class="c28">int</span><span class="c2">&nbsp;n) {</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; </span><span class="c28">cout</span><span class="c2">&nbsp;&lt;&lt; n;</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; </span><span class="c28">if</span><span class="c2">&nbsp;(n % 2 == 0) {</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c28">cout</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c38">&quot; is even &quot;</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c28">endl</span><span class="c2">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++evenCount;</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; } </span><span class="c28">else</span><span class="c2">&nbsp;{</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c28">cout</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c38">&quot; is odd &quot;</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c28">endl</span><span class="c2">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c2">&nbsp; &nbsp;});</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c6">// Print the count of even numbers to the console.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp;</span><span class="c28">cout</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c38">&quot;There are &quot;</span><span class="c2">&nbsp;&lt;&lt; evenCount</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; </span><span class="c38">&quot; even numbers in the vector.&quot;</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c28">endl</span><span class="c2">;</span></p><p class="c1"><span class="c2">}</span></p><p class="c107 c4"><span class="c2"></span></p><p class="c86"><span class="c9">Output:</span></p><p class="c1"><span class="c2">1 is odd</span></p><p class="c1"><span class="c2">2 is even</span></p><p class="c1"><span class="c2">3 is odd</span></p><p class="c1"><span class="c2">4 is even</span></p><p class="c1"><span class="c2">5 is odd</span></p><p class="c1"><span class="c2">6 is even</span></p><p class="c1"><span class="c2">7 is odd</span></p><p class="c1"><span class="c2">8 is even</span></p><p class="c1"><span class="c2">9 is odd</span></p><p class="c1"><span class="c2">There are 4 even numbers in the vector.</span></p><p class="c107 c4"><span class="c2"></span></p><h3 class="c49 c95 c47" id="h.lwraehi2b3nc"><span class="c57 c61">Comments</span></h3><p class="c49 c1 c47"><span class="c9">In the example, the third argument to the for_each function is a lambda. The </span><span class="c56 c54">[&amp;evenCount]</span><span class="c9">&nbsp;part specifies the capture clause of the expression, </span><span class="c56 c54">(int n)</span><span class="c0">&nbsp;specifies the parameter list, and remaining part specifies the body of the expression.</span></p><h2 class="c49 c47 c95" id="h.vq4tfy5dwdmu"><span class="c57 c110 c80 c90 c119">Example 2: Using a Function Object</span></h2><p class="c49 c1 c47"><span class="c9">Sometimes a lambda would be too unwieldy to extend much further than the previous example. The next example uses a function object instead of a lambda, together with the for_each function, to produce the same results as Example 1. Both examples store the count of even numbers in a </span><span class="c56 c54">vector</span><span class="c9">&nbsp;object. To maintain the state of the operation, the </span><span class="c54 c56">FunctorClass</span><span class="c9">&nbsp;class stores the </span><span class="c56 c54">m_evenCount</span><span class="c9">&nbsp;variable by reference as a member variable. To perform the operation, </span><span class="c56 c54">FunctorClass</span><span class="c0">&nbsp;implements the function-call operator, operator(). The Microsoft C++ compiler generates code that is comparable in size and performance to the lambda code in Example 1. For a basic problem like the one in this article, the simpler lambda design is probably better than the function-object design. However, if you think that the functionality might require significant expansion in the future, then use a function object design so that code maintenance will be easier.</span></p><p class="c49 c1 c47"><span class="c9">For more information about the operator(), see </span><span class="c54 c58 c93"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/cpp/function-call-cpp?view%3Dmsvc-170&amp;sa=D&amp;source=editors&amp;ust=1712175539084712&amp;usg=AOvVaw0peK145Vs19W34Ivf9ODfz">Function Call</a></span><span class="c9">. For more information about the for_each function, see </span><span class="c93 c54 c58"><a class="c12" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view%3Dmsvc-170%23for_each&amp;sa=D&amp;source=editors&amp;ust=1712175539085084&amp;usg=AOvVaw0I06WP5xyJhIE76FeYx6HQ">for_each</a></span><span class="c0">.</span></p><p class="c1 c4"><span class="c6 c57 c113"></span></p><p class="c1"><span class="c6">// even_functor.cpp</span></p><p class="c1"><span class="c6">// compile with: /EHsc</span></p><p class="c1"><span class="c44">#include &lt;algorithm&gt;</span></p><p class="c1"><span class="c44">#include &lt;iostream&gt;</span></p><p class="c1"><span class="c44">#include &lt;vector&gt;</span></p><p class="c1"><span class="c28">using</span><span class="c14">&nbsp;</span><span class="c28">namespace</span><span class="c14">&nbsp;</span><span class="c28">std</span><span class="c2">;</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c28">class</span><span class="c14">&nbsp;</span><span class="c44">FunctorClass</span></p><p class="c1"><span class="c2">{</span></p><p class="c1"><span class="c28">public</span><span class="c2">:</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// The required constructor for this example.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">explicit</span><span class="c14">&nbsp;</span><span class="c44">FunctorClass</span><span class="c14">(</span><span class="c28">int</span><span class="c2">&amp; evenCount)</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; : </span><span class="c44">m_evenCount</span><span class="c2">(evenCount) { }</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// The function-call operator prints whether the number is</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// even or odd. If the number is even, this method updates</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// the counter.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">void</span><span class="c14">&nbsp;</span><span class="c44">operator</span><span class="c14">()(</span><span class="c28">int</span><span class="c14">&nbsp;n) </span><span class="c28">const</span><span class="c2">&nbsp;{</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c28">cout</span><span class="c2">&nbsp;&lt;&lt; n;</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c28">if</span><span class="c2">&nbsp;(n % 2 == 0) {</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c28">cout</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c38">&quot; is even &quot;</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c28">endl</span><span class="c2">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++m_evenCount;</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="c28">else</span><span class="c2">&nbsp;{</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c28">cout</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c38">&quot; is odd &quot;</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c28">endl</span><span class="c2">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c28">private</span><span class="c2">:</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// Default assignment operator to silence warning C4512.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; FunctorClass&amp; </span><span class="c28">operator</span><span class="c14">=(</span><span class="c28">const</span><span class="c2">&nbsp;FunctorClass&amp;);</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">int</span><span class="c14">&amp; m_evenCount; </span><span class="c6">// the number of even variables in the vector.</span></p><p class="c1"><span class="c2">};</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c28">int</span><span class="c14">&nbsp;</span><span class="c44">main</span><span class="c2">()</span></p><p class="c1"><span class="c2">{</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// Create a vector object that contains 9 elements.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">vector</span><span class="c14">&lt;</span><span class="c28">int</span><span class="c2">&gt; v;</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">for</span><span class="c14">&nbsp;(</span><span class="c28">int</span><span class="c2">&nbsp;i = 1; i &lt; 10; ++i) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; v.push_back(i);</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// Count the number of even numbers in the vector by</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// using the for_each function and a function object.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">int</span><span class="c2">&nbsp;evenCount = 0;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; for_each(v.begin(), v.end(), FunctorClass(evenCount));</span></p><p class="c1 c4"><span class="c2"></span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c6">// Print the count of even numbers to the console.</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; </span><span class="c28">cout</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c38">&quot;There are &quot;</span><span class="c2">&nbsp;&lt;&lt; evenCount</span></p><p class="c1"><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt; </span><span class="c38">&quot; even numbers in the vector.&quot;</span><span class="c14">&nbsp;&lt;&lt; </span><span class="c28">endl</span><span class="c2">;</span></p><p class="c1"><span class="c2">}</span></p><p class="c107 c4"><span class="c2"></span></p><p class="c86"><span class="c9">Output:</span></p><p class="c1"><span class="c2">1 is odd</span></p><p class="c1"><span class="c2">2 is even</span></p><p class="c1"><span class="c2">3 is odd</span></p><p class="c1"><span class="c2">4 is even</span></p><p class="c1"><span class="c2">5 is odd</span></p><p class="c1"><span class="c2">6 is even</span></p><p class="c1"><span class="c2">7 is odd</span></p><p class="c1"><span class="c2">8 is even</span></p><p class="c1"><span class="c2">9 is odd</span></p><p class="c1"><span class="c2">There are 4 even numbers in the vector.</span></p><p class="c4 c107"><span class="c2"></span></p><p class="c1 c4"><span class="c0"></span></p></body></html>